#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
corrosion_tk_app_rewrite.py

Ø¨Ø±Ù†Ø§Ù…Ø¬ Ù…ØªØ·ÙˆØ± Ù„Ø­Ø³Ø§Ø¨ Ù…Ø¹Ø¯Ù„ Ø§Ù„ØªØ¢ÙƒÙ„ Ù…Ù† Ø¨ÙŠØ§Ù†Ø§Øª Excel.
ÙŠØ³ØªØ®Ø¯Ù… ÙˆØ§Ø¬Ù‡Ø© Ù…Ø³ØªØ®Ø¯Ù… Ø¹Ø±Ø¨ÙŠØ© Ù…ÙØ­Ø³Ù‘Ù†Ø© ÙˆÙŠØ³Ø¬Ù„ Ø§Ù„Ø¹Ù…Ù„ÙŠØ§Øª Ø¨Ø´ÙƒÙ„ Ø£ÙˆØ¶Ø­.
ÙŠØªÙ…ÙŠØ² Ø¨Ø®Ø§ØµÙŠØ© "Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ" Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø© Ù„Ù„ÙƒØ´Ù Ø¹Ù† Ø§Ù„Ù‚ÙŠÙ… Ø§Ù„Ø´Ø§Ø°Ø©.
ÙŠÙ‚ÙˆÙ… Ø¨Ø­ÙØ¸ Ø§Ù„Ù†ØªØ§Ø¦Ø¬ ÙÙŠ Ù…Ù„Ù Ø¥Ø®Ø±Ø§Ø¬ Ø¬Ø¯ÙŠØ¯ Ø¨ØªÙ†Ø³ÙŠÙ‚ Ù…ÙØ­Ø¯Ø¯.
"""

import tkinter as tk
from tkinter import ttk, filedialog, messagebox
from pathlib import Path
import pandas as pd
import numpy as np
import re
from openpyxl import Workbook
from openpyxl.styles import Alignment, Font, Border, Side
from openpyxl.utils import get_column_letter
import datetime

# Attempt to import scikit-learn for AI features
try:
    from sklearn.ensemble import IsolationForest
    from sklearn.preprocessing import RobustScaler
    HAS_SK = True
except ImportError:
    HAS_SK = False

# Import tabulate for instructions formatting
try:
    from tabulate import tabulate
    HAS_TABULATE = True
except ImportError:
    HAS_TABULATE = False

# ------------------ Constants ------------------
DEFAULT_RTV_FACTOR = 2.331
DEFAULT_RTV_CONV = 0.001

# Keywords for part titles
PART_KEYWORDS = ['"', 'inch', 'in', 'Ø§Ù†Ø´', 'Ø§Ù†Ø¨ÙˆØ¨', 'Ø£Ù†Ø¨ÙˆØ¨', 'Ù…Ø­Ø·Ø©', 'Part', 'POINTS', 'Points', 'tube', 'line']

# Expected headers in the input file
INPUT_HEADERS = ['Coth_old (Î¼m)', 'Coth_new (Î¼m)', 'RTV (mm)', 'Thme_new(mm)']
OUTPUT_HEADERS = ['Points', 'COth (mm)', 'THme (mm)', 'RTV (mm)', 'OL (mm)', 'CR (mm)']

# ------------------ Data Processing Functions ------------------

def extract_numbers_from_text(s: str):
    """
    Extracts numbers from a string, supporting comma or period as decimal separators.
    """
    if s is None:
        return []
    s2 = str(s).replace('Ù¬', '.').replace(',', '.').replace('Ù«', '.')
    s2 = s2.replace('\xa0', ' ').replace(' ', '')
    nums = re.findall(r'[-+]?\d*\.\d+|[-+]?\d+', s2)
    return nums

def looks_like_part_title(s: str) -> bool:
    """
    Checks if a string looks like a part title based on keywords and numbers.
    """
    if not isinstance(s, str):
        return False
    s = s.strip()
    if len(s) < 2:
        return False
    for kw in PART_KEYWORDS:
        if kw.lower() in s.lower():
            return True
    if re.search(r'[Ø§Ø£Ø¥Ø¡-ÙŠ]', s) and (re.search(r'Ø£Ù†Ø¨ÙˆØ¨|Ø®Ø·|pipe|line', s, flags=re.I) or re.search(r'\d',s)):
        return True
    return False

def extract_blocks_from_sheet(df: pd.DataFrame):
    """
    Parses an Excel sheet into "blocks", where each block represents a part.
    A block starts with a part title and continues until another title or end of sheet.
    """
    blocks = []
    current_block = None
    df = df.fillna('')
    
    for idx, row in df.iterrows():
        row_text = ' '.join([str(x).strip() for x in row.tolist() if str(x).strip() != ""]).strip()
        
        if not row_text and current_block:
            current_block['lines'].append((idx, row.tolist(), row_text))
            continue
        
        if looks_like_part_title(row_text):
            if current_block:
                blocks.append(current_block)
            current_block = {'title_row': idx, 'title': row_text, 'lines': []}
        elif current_block:
            current_block['lines'].append((idx, row.tolist(), row_text))
    
    if current_block:
        blocks.append(current_block)
    
    return blocks

def parse_block_lines(block):
    """
    Parses lines within a block to extract data points and notes.
    """
    points = []
    notes = []
    capture_notes = False
    
    for i, (idx, rowvals, rowtext) in enumerate(block['lines']):
        text_lower = rowtext.lower()
        
        if 'notes' in text_lower or 'Ù…Ù„Ø§Ø­Ø¸Ø§Øª' in text_lower:
            capture_notes = True
            continue
        
        if capture_notes:
            vals = [str(v).strip() for v in rowvals if str(v).strip() != ""]
            if vals:
                notes.append(' '.join(vals))
            continue
        
        tokens = [str(t).strip() for t in rowvals if str(t).strip() != ""]
        if not tokens:
            continue
            
        label_guess = tokens[0]
        t_join = ' '.join(tokens)
        num_strs = extract_numbers_from_text(t_join)
        
        if not num_strs:
            continue
            
        # Check if the row contains the expected number of values
        if len(num_strs) >= 3:
            try:
                # Assuming the order: Coth_new, Thme_new, RTV (old)
                coth_new = float(num_strs[1])
                thme_new = float(num_strs[2])
                rtv_old = float(num_strs[3])
                
                points.append({
                    'label': label_guess,
                    'Coth_new': coth_new,
                    'Thme_new': thme_new,
                    'RTV_old': rtv_old,
                })
            except (ValueError, IndexError):
                # Ignore rows that don't fit the expected format
                pass
    
    return {'title': block.get('title', ''), 'points': points, 'notes': notes}

def compute_rtv_new(thme_val, coth_val, factor=DEFAULT_RTV_FACTOR):
    """
    Calculates the new RTV value based on the formula.
    """
    try:
        if thme_val is None or coth_val is None:
            return None
        th = float(thme_val)
        co = float(coth_val)
        return th - (float(factor) * co * DEFAULT_RTV_CONV)
    except Exception:
        return None

def compute_cr(rtv_old, rtv_new):
    """
    Calculates the Corrosion Rate (CR) from old and new RTV values.
    """
    try:
        if rtv_old is None or rtv_new is None:
            return None
        return float(rtv_old) - float(rtv_new)
    except Exception:
        return None

def extract_diameter_from_title(title: str):
    """
    Extracts the diameter in inches from a part title.
    Example: "Pipe 12 inch" -> "12" or "10\" Line" -> "10"
    """
    if not isinstance(title, str):
        return ''
    m = re.search(r"(\d+(?:\.\d+)?)\s*(?:\"|in|inch|inches|Ø§Ù†Ø´)", title, flags=re.I)
    if m:
        return m.group(1)
    m2 = re.search(r'(\d+(?:\.\d+)?)"', title)
    if m2:
        return m2.group(1)
    return ''

def detect_anomalies(df_numeric):
    """
    Uses RobustScaler and IsolationForest to detect anomalies.
    """
    if not HAS_SK or df_numeric.empty or len(df_numeric) < 2:
        return np.array([False] * len(df_numeric))
    try:
        X = df_numeric.fillna(df_numeric.mean())
        scaler = RobustScaler()
        Xs = scaler.fit_transform(X)
        iso = IsolationForest(random_state=42, n_estimators=100, contamination='auto')
        preds = iso.fit_predict(Xs)
        return preds == -1
    except Exception:
        return np.array([False] * len(df_numeric))

# ------------------ Main Processing Logic ------------------

def process_excel_file(input_path: str, output_path: str, rtv_factor: float, enable_ai: bool, log_callback=None):
    """
    Reads the Excel file, processes the data, and saves the results in a new file.
    """
    if log_callback is None:
        log_callback = print

    inp = Path(input_path)
    if not inp.exists():
        raise FileNotFoundError(f'Input file not found: {inp}')

    log_callback(f'Starting to read file: {inp.name}...')
    try:
        xls = pd.read_excel(inp, sheet_name=None, header=None, dtype=str)
    except Exception as e:
        raise ValueError(f'Error reading Excel file: {e}')

    parts_data = []
    for sheet_name, df in xls.items():
        log_callback(f'--- Analyzing sheet "{sheet_name}" ---')
        blocks = extract_blocks_from_sheet(df)
        log_callback(f'Found {len(blocks)} potential blocks (parts).')
        for i, b in enumerate(blocks):
            parsed = parse_block_lines(b)
            parsed['sheet_name'] = sheet_name
            parts_data.append(parsed)

    if not parts_data:
        raise ValueError('No valid part data found in the file.')

    wb = Workbook()
    ws = wb.active
    ws.title = 'Results'
    row_idx = 1
    
    thin_border = Border(left=Side(style='thin'), 
                         right=Side(style='thin'), 
                         top=Side(style='thin'), 
                         bottom=Side(style='thin'))
    
    bold_font = Font(bold=True)
    
    for i, part in enumerate(parts_data):
        log_callback(f'-- Processing part no. {i + 1}: "{part.get("title", "No Name")}" --')
        
        title = part.get('title', '')
        diameter = extract_diameter_from_title(title)
        
        # Write part title and diameter
        ws.cell(row=row_idx, column=1, value='Ø§Ø³Ù… Ø§Ù„Ø¬Ø²Ø¡:').font = bold_font
        ws.cell(row=row_idx, column=2, value=title)
        ws.cell(row=row_idx, column=4, value='Ù‚Ø·Ø±Ù‡ Ø¨Ø§Ù„Ø§Ù†Ø´:').font = bold_font
        ws.cell(row=row_idx, column=5, value=diameter if diameter else 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯')
        
        row_idx += 2
        
        # Write table headers
        for col_num, header_text in enumerate(OUTPUT_HEADERS, start=1):
            cell = ws.cell(row=row_idx, column=col_num, value=header_text)
            cell.font = bold_font
            cell.alignment = Alignment(horizontal='center')
            cell.border = thin_border
        
        if enable_ai:
            ai_header_cell = ws.cell(row=row_idx, column=len(OUTPUT_HEADERS) + 1, value='Ù…Ù„Ø§Ø­Ø¸Ø§Øª Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ')
            ai_header_cell.font = bold_font
            ai_header_cell.alignment = Alignment(horizontal='center')
            ai_header_cell.border = thin_border
        
        row_idx += 1
        
        points_to_write = []
        numeric_data = []
        
        for p in part.get('points', []):
            rtv_old = p.get('RTV_old')
            coth_new = p.get('Coth_new')
            thme_new = p.get('Thme_new')
            
            rtv_new = compute_rtv_new(thme_new, coth_new, factor=rtv_factor)
            cr = compute_cr(rtv_old, rtv_new)
            
            numeric_data.append({
                'COth_new': coth_new,
                'THme_new': thme_new,
                'RTV_old': rtv_old,
                'RTV_new': rtv_new,
                'CR': cr,
            })
            
            points_to_write.append({
                'label': p.get('label'),
                'Coth_new': coth_new,
                'Thme_new': thme_new,
                'RTV_old': rtv_old,
                'RTV_new': rtv_new,
                'CR': cr,
            })
            
        log_callback(f'Found {len(points_to_write)} data points.')
        
        # Anomaly detection
        anomaly_mask = np.array([False] * len(numeric_data))
        if enable_ai and len(numeric_data) > 1:
            df_numeric = pd.DataFrame(numeric_data)
            anomaly_mask = detect_anomalies(df_numeric)
            anomalies_count = np.sum(anomaly_mask)
            if anomalies_count > 0:
                log_callback(f'âœ¨ AI enabled: Found {anomalies_count} anomalies!')
            else:
                log_callback('âœ¨ AI enabled: No anomalies found.')
        
        # Write data to table
        for j, point in enumerate(points_to_write):
            ws.cell(row=row_idx, column=1, value=point['label']).border = thin_border
            ws.cell(row=row_idx, column=2, value=point['Coth_new']).border = thin_border
            ws.cell(row=row_idx, column=3, value=point['Thme_new']).border = thin_border
            ws.cell(row=row_idx, column=4, value=point['RTV_new']).border = thin_border
            ws.cell(row=row_idx, column=5, value=point['RTV_old']).border = thin_border
            ws.cell(row=row_idx, column=6, value=point['CR']).border = thin_border
            
            if enable_ai and anomaly_mask[j]:
                ws.cell(row=row_idx, column=len(OUTPUT_HEADERS) + 1, value='Ù‚ÙŠÙ…Ø© Ø´Ø§Ø°Ø©').font = Font(color="FF0000")
            
            row_idx += 1
        
        # Add notes
        if part.get('notes'):
            row_idx += 1
            ws.cell(row=row_idx, column=1, value='Ø§Ù„Ù…Ù„Ø§Ø­Ø¸Ø§Øª:').font = bold_font
            notes_text = '\n'.join(part.get('notes'))
            note_cell = ws.cell(row=row_idx, column=2, value=notes_text)
            note_cell.alignment = Alignment(wrap_text=True, vertical='top')
            ws.merge_cells(start_row=row_idx, start_column=2, end_row=row_idx, end_column=len(OUTPUT_HEADERS) + 1)
            row_idx += 1
        
        # Add visual separator
        row_idx += 2
        
    # Adjust column widths
    for col in range(1, len(OUTPUT_HEADERS) + 2):
        ws.column_dimensions[get_column_letter(col)].width = 25
        
    try:
        wb.save(output_path)
    except Exception as e:
        raise IOError(f'Failed to save file: {e}')
    
    return output_path

# ------------------ User Interface (Arabic) ------------------

class CorrosionApp(tk.Tk):
    def __init__(self):
        super().__init__()
        self.title('Ø­Ø§Ø³Ø¨Ø© Ù…Ø¹Ø¯Ù„ Ø§Ù„ØªØ¢ÙƒÙ„ â€” Ù†Ø³Ø®Ø© Ù…ØªØ·ÙˆØ±Ø©')
        self.geometry('1000x700')
        
        self.input_path = tk.StringVar()
        self.output_path = tk.StringVar()
        self.rtv_factor = tk.DoubleVar(value=DEFAULT_RTV_FACTOR)
        self.enable_ai = tk.BooleanVar(value=True)
        
        self.notebook = ttk.Notebook(self)
        self.notebook.pack(fill='both', expand=True, padx=15, pady=15)
        
        self.create_main_tab()
        self.create_instructions_tab()
    
    def create_main_tab(self):
        main_tab = ttk.Frame(self.notebook, padding=(10, 10))
        self.notebook.add(main_tab, text='Ø§Ù„Ø­Ø§Ø³Ø¨Ø©')
        
        # Files Frame
        file_frame = ttk.LabelFrame(main_tab, text='Ø§Ø®ØªÙŠØ§Ø± Ù…Ù„ÙØ§Øª Ø§Ù„Ø¥Ø¯Ø®Ø§Ù„ ÙˆØ§Ù„Ø¥Ø®Ø±Ø§Ø¬', padding=(10, 10))
        file_frame.pack(fill='x', pady=10)
        
        ttk.Label(file_frame, text='Ù…Ø³Ø§Ø± Ù…Ù„Ù Ø§Ù„Ø¥Ø¯Ø®Ø§Ù„ (Excel):').grid(row=0, column=0, sticky='w', padx=5, pady=5)
        ttk.Entry(file_frame, textvariable=self.input_path, width=80).grid(row=0, column=1, padx=5, pady=5)
        ttk.Button(file_frame, text='ØªØµÙØ­...', command=self.select_input).grid(row=0, column=2, padx=5, pady=5)
        
        ttk.Label(file_frame, text='Ù…Ø³Ø§Ø± Ù…Ù„Ù Ø§Ù„Ø¥Ø®Ø±Ø§Ø¬ (Excel):').grid(row=1, column=0, sticky='w', padx=5, pady=5)
        ttk.Entry(file_frame, textvariable=self.output_path, width=80).grid(row=1, column=1, padx=5, pady=5)
        ttk.Button(file_frame, text='ØªØµÙØ­...', command=self.select_output).grid(row=1, column=2, padx=5, pady=5)
        
        # Settings Frame
        settings_frame = ttk.LabelFrame(main_tab, text='Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø©', padding=(10, 10))
        settings_frame.pack(fill='x', pady=10)
        
        ttk.Label(settings_frame, text='Ø¹Ø§Ù…Ù„ RTV (RTV Factor):').grid(row=0, column=0, sticky='w', padx=5, pady=5)
        ttk.Entry(settings_frame, textvariable=self.rtv_factor, width=15).grid(row=0, column=1, padx=5, pady=5)
        
        if HAS_SK:
            ttk.Checkbutton(settings_frame, text='ØªÙØ¹ÙŠÙ„ Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ Ù„Ù„ÙƒØ´Ù Ø¹Ù† Ø§Ù„Ù‚ÙŠÙ… Ø§Ù„Ø´Ø§Ø°Ø©', variable=self.enable_ai).grid(row=1, column=0, columnspan=4, sticky='w', padx=5, pady=5)
        else:
            ttk.Label(settings_frame, text='âš ï¸ Ù„Ø§ ÙŠÙ…ÙƒÙ† ØªÙØ¹ÙŠÙ„ Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ. Ù‚Ù… Ø¨ØªØ«Ø¨ÙŠØª scikit-learn.').grid(row=1, column=0, columnspan=4, sticky='w', padx=5, pady=5)
            self.enable_ai.set(False)
            
        # Action Buttons
        action_frame = ttk.Frame(main_tab)
        action_frame.pack(fill='x', pady=10)
        ttk.Button(action_frame, text='Ù…Ø¹Ø§ÙŠÙ†Ø© Ø§Ù„Ù…Ù„Ù', command=self.preview_input).pack(side='left', padx=10, ipady=5)
        ttk.Button(action_frame, text='ØªØ´ØºÙŠÙ„ ÙˆØ­ÙØ¸ Ø§Ù„Ù†ØªØ§Ø¦Ø¬', command=self.run_processing).pack(side='left', padx=10, ipady=5)
        ttk.Button(action_frame, text='Ø¥ØºÙ„Ø§Ù‚', command=self.quit).pack(side='right', padx=10, ipady=5)
        
        # Log Panel
        log_frame = ttk.LabelFrame(main_tab, text='Ø³Ø¬Ù„ Ø§Ù„Ø¹Ù…Ù„ÙŠØ§Øª ÙˆØ§Ù„ØªÙ‚Ø§Ø±ÙŠØ±', padding=(10, 10))
        log_frame.pack(fill='both', expand=True, pady=10)
        
        self.txt = tk.Text(log_frame, wrap='word', height=15, state='disabled', font=('Courier New', 10))
        self.txt.pack(fill='both', expand=True)
        
        self.log_message('Ù…Ø±Ø­Ø¨Ø§Ù‹ Ø¨Ùƒ ÙÙŠ Ø­Ø§Ø³Ø¨Ø© Ù…Ø¹Ø¯Ù„ Ø§Ù„ØªØ¢ÙƒÙ„. Ø§Ø¨Ø¯Ø£ Ø¨Ø§Ø®ØªÙŠØ§Ø± Ù…Ù„Ù Ø§Ù„Ø¥Ø¯Ø®Ø§Ù„ Ø«Ù… Ù…Ù„Ù Ø§Ù„Ø¥Ø®Ø±Ø§Ø¬.')

    def create_instructions_tab(self):
        instructions_tab = ttk.Frame(self.notebook, padding=(10, 10))
        self.notebook.add(instructions_tab, text='Ø§Ù„ØªØ¹Ù„ÙŠÙ…Ø§Øª')
        
        instructions_text = tk.Text(instructions_tab, wrap='word', font=('Courier New', 10), state='disabled')
        instructions_text.pack(fill='both', expand=True)
        
        instructions_text.config(state='normal')
        
        # Use a more compatible way to style fonts
        instructions_text.tag_configure('title', font='TkDefaultFont 14 bold')
        instructions_text.tag_configure('section', font='TkDefaultFont 12 bold')

        instructions_text.insert('end', ' Ø¯Ù„ÙŠÙ„ Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø­Ø§Ø³Ø¨Ø© Ù…Ø¹Ø¯Ù„ Ø§Ù„ØªØ¢ÙƒÙ„ \n', 'title')
        instructions_text.insert('end', '---------------------------------------\n\n')
        
        instructions_text.insert('end', '1. ØªÙ†Ø³ÙŠÙ‚ Ù…Ù„Ù Ø§Ù„Ø¥Ø¯Ø®Ø§Ù„ \n', 'section')
        instructions_text.insert('end', 'ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† Ù…Ù„Ù Ø§Ù„Ø¥Ø¯Ø®Ø§Ù„ Ø¨ØªÙ†Ø³ÙŠÙ‚ Excel (.xlsx) ÙˆÙ…Ù†Ø¸Ù…Ø§Ù‹ Ø¨Ø´ÙƒÙ„ Ù…Ø­Ø¯Ø¯. ÙƒÙ„ Ø¬Ø²Ø¡ Ø£Ùˆ Ø£Ù†Ø¨ÙˆØ¨ ÙŠØ¬Ø¨ Ø£Ù† ÙŠØ¨Ø¯Ø£ Ø¨ØµÙ ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ Ø§Ø³Ù…Ù‡ ÙˆÙ‚Ø·Ø±Ù‡ (Ù…Ø«Ø§Ù„: "Ø£Ù†Ø¨ÙˆØ¨ Ø§Ù„Ø¯Ø®ÙˆÙ„ Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ Ù…Ù† Ø§Ù„Ù†Ù‡Ø± (Ø§Ù„Ù…ØµØ¯Ø± Ø§Ù„Ø§ÙˆÙ„) 12""). Ø¨Ø¹Ø¯ Ø°Ù„ÙƒØŒ ÙŠØ¬Ø¨ Ø£Ù† ØªØ£ØªÙŠ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ÙÙŠ ØµÙÙˆÙØŒ Ù…Ø¹ ÙˆØ¬ÙˆØ¯ Ø±Ø¤ÙˆØ³ Ø£Ø¹Ù…Ø¯Ø© Ù…Ø­Ø¯Ø¯Ø©.\n\n')
        
        if HAS_TABULATE:
            headers_table = [['Ø±Ø£Ø³ Ø§Ù„Ø¹Ù…ÙˆØ¯', 'Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ØªÙŠ ÙŠÙ…Ø«Ù„Ù‡Ø§'],
                             ['Coth_new (Î¼m)', 'Ù‚ÙŠÙ…Ø© Ø§Ù„Ø·Ù„Ø§Ø¡ Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©'],
                             ['Thme_new(mm)', 'Ù‚ÙŠÙ…Ø© Ø§Ù„Ø³Ù…Ùƒ Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©'],
                             ['RTV (mm)', 'Ù‚ÙŠÙ…Ø© RTV Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø©'],
                             ['Notes', 'Ø§Ù„Ù…Ù„Ø§Ø­Ø¸Ø§Øª']]
            table_str = tabulate(headers_table, headers='firstrow', tablefmt='pipe', numalign='center', stralign='right')
            instructions_text.insert('end', '  - Ø±Ø¤ÙˆØ³ Ø§Ù„Ø£Ø¹Ù…Ø¯Ø© Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø© ÙÙŠ Ø§Ù„Ø¥Ø¯Ø®Ø§Ù„:\n')
            instructions_text.insert('end', table_str + '\n\n')
        else:
            instructions_text.insert('end', '  - Ø±Ø¤ÙˆØ³ Ø§Ù„Ø£Ø¹Ù…Ø¯Ø© Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø© ÙÙŠ Ø§Ù„Ø¥Ø¯Ø®Ø§Ù„:\n')
            instructions_text.insert('end', '  - Coth_new (Î¼m)\n')
            instructions_text.insert('end', '  - Thme_new(mm)\n')
            instructions_text.insert('end', '  - RTV (mm) (Ø§Ù„Ù‚ÙŠÙ…Ø© Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø©)\n')
            instructions_text.insert('end', '  - Notes (Ù„Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ù„Ø§Ø­Ø¸Ø§Øª)\n\n')
            
        instructions_text.insert('end', '2. Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª ÙÙŠ Ø§Ù„Ø¨Ø±Ù†Ø§Ù…Ø¬ \n', 'section')
        instructions_text.insert('end', 'ÙŠÙ‚ÙˆÙ… Ø§Ù„Ø¨Ø±Ù†Ø§Ù…Ø¬ Ø¨Ø­Ø³Ø§Ø¨ Ø§Ù„Ù‚ÙŠÙ… Ø§Ù„ØªØ§Ù„ÙŠØ© ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§:\n\n')
        
        instructions_text.insert('end', '  - Ø­Ø³Ø§Ø¨ RTV Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø© (RTV (mm))\n')
        instructions_text.insert('end', '    * Ø§Ù„Ù…Ø¹Ø§Ø¯Ù„Ø©: $RTV (mm) = Thme_{new} - (2.331 \times Coth_{new} \times 0.001)$\n\n')
        
        instructions_text.insert('end', '  - Ø­Ø³Ø§Ø¨ Ù…Ø¹Ø¯Ù„ Ø§Ù„ØªØ¢ÙƒÙ„ (CR (mm))\n')
        instructions_text.insert('end', '    * Ø§Ù„Ù…Ø¹Ø§Ø¯Ù„Ø©: $CR (mm) = RTV_{old} - RTV_{new}$\n\n')
        
        instructions_text.insert('end', '3. ØªÙ†Ø³ÙŠÙ‚ Ù…Ù„Ù Ø§Ù„Ø¥Ø®Ø±Ø§Ø¬ \n', 'section')
        instructions_text.insert('end', 'Ø³ÙŠØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ù…Ù„Ù Excel Ø¬Ø¯ÙŠØ¯ Ø¨Ø§Ù„ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„ØªØ§Ù„ÙŠ Ù„ÙƒÙ„ Ø¬Ø²Ø¡:\n')
        instructions_text.insert('end', '  - Ø£ÙˆÙ„Ø§Ù‹: Ø§Ø³Ù… Ø§Ù„Ø¬Ø²Ø¡ ÙˆÙ‚Ø·Ø±Ù‡.\n')
        instructions_text.insert('end', '  - Ø«Ø§Ù†ÙŠØ§Ù‹: Ø¬Ø¯ÙˆÙ„ Ø¨Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø­Ø³ÙˆØ¨Ø© (Ø§Ù„ØªÙŠ ØªØªØ¶Ù…Ù† Ø±Ø¤ÙˆØ³ Ø§Ù„Ø£Ø¹Ù…Ø¯Ø© Ø§Ù„ØªØ§Ù„ÙŠØ©):\n')
        
        if HAS_TABULATE:
            output_headers_table = [['Ø±Ø£Ø³ Ø§Ù„Ø¹Ù…ÙˆØ¯', 'Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ØªÙŠ ÙŠÙ…Ø«Ù„Ù‡Ø§'],
                                    ['Points', 'Ø±Ù‚Ù… Ø§Ù„Ù†Ù‚Ø·Ø©'],
                                    ['COth (mm)', 'Ù‚ÙŠÙ…Ø© Ø§Ù„Ø·Ù„Ø§Ø¡ Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©'],
                                    ['THme (mm)', 'Ù‚ÙŠÙ…Ø© Ø§Ù„Ø³Ù…Ùƒ Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©'],
                                    ['RTV (mm)', 'Ù‚ÙŠÙ…Ø© RTV Ø§Ù„Ù…Ø­Ø³ÙˆØ¨Ø©'],
                                    ['OL (mm)', 'Ù‚ÙŠÙ…Ø© RTV Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø© Ù…Ù† Ø§Ù„Ø¥Ø¯Ø®Ø§Ù„'],
                                    ['CR (mm)', 'Ù…Ø¹Ø¯Ù„ Ø§Ù„ØªØ¢ÙƒÙ„ Ø§Ù„Ù…Ø­Ø³ÙˆØ¨']]
            table_str = tabulate(output_headers_table, headers='firstrow', tablefmt='pipe', numalign='center', stralign='right')
            instructions_text.insert('end', table_str + '\n\n')
        else:
            instructions_text.insert('end', '  - Points\n  - COth (mm)\n  - THme (mm)\n  - RTV (mm)\n  - OL (mm)\n  - CR (mm)\n\n')
        
        instructions_text.insert('end', '  - Ø«Ø§Ù„Ø«Ø§Ù‹: Ø§Ù„Ù…Ù„Ø§Ø­Ø¸Ø§Øª Ø§Ù„Ù…ÙˆØ¬ÙˆØ¯Ø© ÙÙŠ Ù…Ù„Ù Ø§Ù„Ø¥Ø¯Ø®Ø§Ù„.\n')
        
        instructions_text.config(state='disabled')

    def log_message(self, msg):
        """
        Adds a new message to the log panel with a timestamp.
        """
        timestamp = datetime.datetime.now().strftime('%H:%M:%S')
        log_entry = f'[{timestamp}] {msg}\n'
        self.txt.config(state='normal')
        self.txt.insert('end', log_entry)
        self.txt.see('end')
        self.txt.config(state='disabled')

    def select_input(self):
        p = filedialog.askopenfilename(title='Ø§Ø®ØªÙŠØ§Ø± Ù…Ù„Ù Ø§Ù„Ø¥Ø¯Ø®Ø§Ù„', filetypes=[('Excel files', '*.xlsx;*.xls')])
        if p:
            self.input_path.set(p)
            self.log_message(f'âœ… ØªÙ… Ø§Ø®ØªÙŠØ§Ø± Ù…Ù„Ù Ø§Ù„Ø¥Ø¯Ø®Ø§Ù„ Ø¨Ù†Ø¬Ø§Ø­: {Path(p).name}')
            
    def select_output(self):
        p = filedialog.asksaveasfilename(title='Ø§Ø®ØªÙŠØ§Ø± Ù…Ù„Ù Ø§Ù„Ø¥Ø®Ø±Ø§Ø¬', defaultextension='.xlsx', filetypes=[('Excel files', '*.xlsx')])
        if p:
            self.output_path.set(p)
            self.log_message(f'âœ… ØªÙ… Ø§Ø®ØªÙŠØ§Ø± Ù…Ø³Ø§Ø± Ø§Ù„Ø¥Ø®Ø±Ø§Ø¬: {Path(p).name}')

    def preview_input(self):
        p = self.input_path.get().strip()
        if not p:
            messagebox.showwarning('ØªØ­Ø°ÙŠØ±', 'Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø§Ø®ØªÙŠØ§Ø± Ù…Ù„Ù Ø¥Ø¯Ø®Ø§Ù„ Ø£ÙˆÙ„Ø§Ù‹.')
            return
        
        self.log_message('âš ï¸ Ø¬Ø§Ø±ÙŠ Ù…Ø¹Ø§ÙŠÙ†Ø© Ø§Ù„Ù…Ù„Ù. Ù‡Ø°Ù‡ Ø§Ù„Ø¹Ù…Ù„ÙŠØ© Ù„Ø§ ØªØ­ÙØ¸ Ø£ÙŠ Ø´ÙŠØ¡.')
        try:
            xls = pd.read_excel(p, sheet_name=None, header=None, dtype=str)
            self.log_message(f'âœ… ØªÙ… ÙØªØ­ Ø§Ù„Ù…Ù„Ù: {Path(p).name} Ø¨Ù†Ø¬Ø§Ø­.')
            for sheet_name, df in xls.items():
                self.log_message(f'   - ÙˆØ±Ù‚Ø© Ø§Ù„Ø¹Ù…Ù„: "{sheet_name}" Ø¨Ø£Ø¨Ø¹Ø§Ø¯ {df.shape[0]} ØµÙ Ùˆ {df.shape[1]} Ø¹Ù…ÙˆØ¯.')
        except Exception as e:
            messagebox.showerror('Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ù…Ø¹Ø§ÙŠÙ†Ø©', f'Ø­Ø¯Ø« Ø®Ø·Ø£: {e}')
            self.log_message(f'âŒ ÙØ´Ù„Øª Ø§Ù„Ù…Ø¹Ø§ÙŠÙ†Ø©: {e}')
            
    def run_processing(self):
        inp = self.input_path.get().strip()
        outp = self.output_path.get().strip()
        
        if not inp:
            messagebox.showwarning('ØªØ­Ø°ÙŠØ±', 'ÙŠØ¬Ø¨ Ø§Ø®ØªÙŠØ§Ø± Ù…Ù„Ù Ø¥Ø¯Ø®Ø§Ù„.')
            return
        
        if not outp:
            inp_path = Path(inp)
            outp = str(inp_path.with_name(f'{inp_path.stem}_results.xlsx'))
            self.output_path.set(outp)
            self.log_message(f'â— Ù„Ù… ÙŠØªÙ… ØªØ­Ø¯ÙŠØ¯ Ù…Ù„Ù Ø¥Ø®Ø±Ø§Ø¬. Ø³ÙŠØªÙ… Ø§Ù„Ø­ÙØ¸ ØªÙ„Ù‚Ø§Ø¦ÙŠÙ‹Ø§ ÙÙŠ: {Path(outp).name}')
            
        try:
            self.log_message('ğŸš€ Ø¨Ø¯Ø¡ Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø©... Ù‚Ø¯ ÙŠØ³ØªØºØ±Ù‚ Ø§Ù„Ø£Ù…Ø± Ø¨Ø¹Ø¶ Ø§Ù„ÙˆÙ‚Øª.')
            self.log_message('---------------------------------------')
            
            process_excel_file(
                input_path=inp,
                output_path=outp,
                rtv_factor=self.rtv_factor.get(),
                enable_ai=self.enable_ai.get(),
                log_callback=self.log_message
            )
            
            self.log_message('---------------------------------------')
            self.log_message(f'âœ… Ø§ÙƒØªÙ…Ù„Øª Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø© Ø¨Ù†Ø¬Ø§Ø­. ØªÙ… Ø­ÙØ¸ Ø§Ù„Ù†ØªØ§Ø¦Ø¬ ÙÙŠ: {Path(outp).name}')
            messagebox.showinfo('Ù†Ø¬Ø§Ø­', f'Ø§ÙƒØªÙ…Ù„Øª Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø©. ØªÙ… Ø­ÙØ¸ Ø§Ù„Ù†ØªØ§Ø¦Ø¬ ÙÙŠ:\n{outp}')
            
        except Exception as e:
            messagebox.showerror('Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø©', f'Ø­Ø¯Ø« Ø®Ø·Ø£ ØºÙŠØ± Ù…ØªÙˆÙ‚Ø¹: {e}')
            self.log_message(f'âŒ ÙØ´Ù„Øª Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø©: {e}')

if __name__ == '__main__':
    app = CorrosionApp()
    app.mainloop()
