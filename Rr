#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
corrosion_tk_app_rewrite.py

برنامج متطور لحساب معدل التآكل من بيانات Excel.
يستخدم واجهة مستخدم عربية مُحسّنة ويسجل العمليات بشكل أوضح.
يتميز بخاصية "الذكاء الاصطناعي" المتقدمة للكشف عن القيم الشاذة.
يقوم بحفظ النتائج في ملف إخراج جديد بتنسيق مُحدد.
"""

import tkinter as tk
from tkinter import ttk, filedialog, messagebox
from pathlib import Path
import pandas as pd
import numpy as np
import re
from openpyxl import Workbook
from openpyxl.styles import Alignment, Font, Border, Side
from openpyxl.utils import get_column_letter
import datetime

# Attempt to import scikit-learn for AI features
try:
    from sklearn.ensemble import IsolationForest
    from sklearn.preprocessing import RobustScaler
    HAS_SK = True
except ImportError:
    HAS_SK = False

# Import tabulate for instructions formatting
try:
    from tabulate import tabulate
    HAS_TABULATE = True
except ImportError:
    HAS_TABULATE = False

# ------------------ Constants ------------------
DEFAULT_RTV_FACTOR = 2.331
DEFAULT_RTV_CONV = 0.001

# Keywords for part titles
PART_KEYWORDS = ['"', 'inch', 'in', 'انش', 'انبوب', 'أنبوب', 'محطة', 'Part', 'POINTS', 'Points', 'tube', 'line']

# Expected headers in the input file
INPUT_HEADERS = ['Coth_old (μm)', 'Coth_new (μm)', 'RTV (mm)', 'Thme_new(mm)']
OUTPUT_HEADERS = ['Points', 'COth (mm)', 'THme (mm)', 'RTV (mm)', 'OL (mm)', 'CR (mm)']

# ------------------ Data Processing Functions ------------------

def extract_numbers_from_text(s: str):
    """
    Extracts numbers from a string, supporting comma or period as decimal separators.
    """
    if s is None:
        return []
    s2 = str(s).replace('٬', '.').replace(',', '.').replace('٫', '.')
    s2 = s2.replace('\xa0', ' ').replace(' ', '')
    nums = re.findall(r'[-+]?\d*\.\d+|[-+]?\d+', s2)
    return nums

def looks_like_part_title(s: str) -> bool:
    """
    Checks if a string looks like a part title based on keywords and numbers.
    """
    if not isinstance(s, str):
        return False
    s = s.strip()
    if len(s) < 2:
        return False
    for kw in PART_KEYWORDS:
        if kw.lower() in s.lower():
            return True
    if re.search(r'[اأإء-ي]', s) and (re.search(r'أنبوب|خط|pipe|line', s, flags=re.I) or re.search(r'\d',s)):
        return True
    return False

def extract_blocks_from_sheet(df: pd.DataFrame):
    """
    Parses an Excel sheet into "blocks", where each block represents a part.
    A block starts with a part title and continues until another title or end of sheet.
    """
    blocks = []
    current_block = None
    df = df.fillna('')
    
    for idx, row in df.iterrows():
        row_text = ' '.join([str(x).strip() for x in row.tolist() if str(x).strip() != ""]).strip()
        
        if not row_text and current_block:
            current_block['lines'].append((idx, row.tolist(), row_text))
            continue
        
        if looks_like_part_title(row_text):
            if current_block:
                blocks.append(current_block)
            current_block = {'title_row': idx, 'title': row_text, 'lines': []}
        elif current_block:
            current_block['lines'].append((idx, row.tolist(), row_text))
    
    if current_block:
        blocks.append(current_block)
    
    return blocks

def parse_block_lines(block):
    """
    Parses lines within a block to extract data points and notes.
    """
    points = []
    notes = []
    capture_notes = False
    
    for i, (idx, rowvals, rowtext) in enumerate(block['lines']):
        text_lower = rowtext.lower()
        
        if 'notes' in text_lower or 'ملاحظات' in text_lower:
            capture_notes = True
            continue
        
        if capture_notes:
            vals = [str(v).strip() for v in rowvals if str(v).strip() != ""]
            if vals:
                notes.append(' '.join(vals))
            continue
        
        tokens = [str(t).strip() for t in rowvals if str(t).strip() != ""]
        if not tokens:
            continue
            
        label_guess = tokens[0]
        t_join = ' '.join(tokens)
        num_strs = extract_numbers_from_text(t_join)
        
        if not num_strs:
            continue
            
        # Check if the row contains the expected number of values
        if len(num_strs) >= 3:
            try:
                # Assuming the order: Coth_new, Thme_new, RTV (old)
                coth_new = float(num_strs[1])
                thme_new = float(num_strs[2])
                rtv_old = float(num_strs[3])
                
                points.append({
                    'label': label_guess,
                    'Coth_new': coth_new,
                    'Thme_new': thme_new,
                    'RTV_old': rtv_old,
                })
            except (ValueError, IndexError):
                # Ignore rows that don't fit the expected format
                pass
    
    return {'title': block.get('title', ''), 'points': points, 'notes': notes}

def compute_rtv_new(thme_val, coth_val, factor=DEFAULT_RTV_FACTOR):
    """
    Calculates the new RTV value based on the formula.
    """
    try:
        if thme_val is None or coth_val is None:
            return None
        th = float(thme_val)
        co = float(coth_val)
        return th - (float(factor) * co * DEFAULT_RTV_CONV)
    except Exception:
        return None

def compute_cr(rtv_old, rtv_new):
    """
    Calculates the Corrosion Rate (CR) from old and new RTV values.
    """
    try:
        if rtv_old is None or rtv_new is None:
            return None
        return float(rtv_old) - float(rtv_new)
    except Exception:
        return None

def extract_diameter_from_title(title: str):
    """
    Extracts the diameter in inches from a part title.
    Example: "Pipe 12 inch" -> "12" or "10\" Line" -> "10"
    """
    if not isinstance(title, str):
        return ''
    m = re.search(r"(\d+(?:\.\d+)?)\s*(?:\"|in|inch|inches|انش)", title, flags=re.I)
    if m:
        return m.group(1)
    m2 = re.search(r'(\d+(?:\.\d+)?)"', title)
    if m2:
        return m2.group(1)
    return ''

def detect_anomalies(df_numeric):
    """
    Uses RobustScaler and IsolationForest to detect anomalies.
    """
    if not HAS_SK or df_numeric.empty or len(df_numeric) < 2:
        return np.array([False] * len(df_numeric))
    try:
        X = df_numeric.fillna(df_numeric.mean())
        scaler = RobustScaler()
        Xs = scaler.fit_transform(X)
        iso = IsolationForest(random_state=42, n_estimators=100, contamination='auto')
        preds = iso.fit_predict(Xs)
        return preds == -1
    except Exception:
        return np.array([False] * len(df_numeric))

# ------------------ Main Processing Logic ------------------

def process_excel_file(input_path: str, output_path: str, rtv_factor: float, enable_ai: bool, log_callback=None):
    """
    Reads the Excel file, processes the data, and saves the results in a new file.
    """
    if log_callback is None:
        log_callback = print

    inp = Path(input_path)
    if not inp.exists():
        raise FileNotFoundError(f'Input file not found: {inp}')

    log_callback(f'Starting to read file: {inp.name}...')
    try:
        xls = pd.read_excel(inp, sheet_name=None, header=None, dtype=str)
    except Exception as e:
        raise ValueError(f'Error reading Excel file: {e}')

    parts_data = []
    for sheet_name, df in xls.items():
        log_callback(f'--- Analyzing sheet "{sheet_name}" ---')
        blocks = extract_blocks_from_sheet(df)
        log_callback(f'Found {len(blocks)} potential blocks (parts).')
        for i, b in enumerate(blocks):
            parsed = parse_block_lines(b)
            parsed['sheet_name'] = sheet_name
            parts_data.append(parsed)

    if not parts_data:
        raise ValueError('No valid part data found in the file.')

    wb = Workbook()
    ws = wb.active
    ws.title = 'Results'
    row_idx = 1
    
    thin_border = Border(left=Side(style='thin'), 
                         right=Side(style='thin'), 
                         top=Side(style='thin'), 
                         bottom=Side(style='thin'))
    
    bold_font = Font(bold=True)
    
    for i, part in enumerate(parts_data):
        log_callback(f'-- Processing part no. {i + 1}: "{part.get("title", "No Name")}" --')
        
        title = part.get('title', '')
        diameter = extract_diameter_from_title(title)
        
        # Write part title and diameter
        ws.cell(row=row_idx, column=1, value='اسم الجزء:').font = bold_font
        ws.cell(row=row_idx, column=2, value=title)
        ws.cell(row=row_idx, column=4, value='قطره بالانش:').font = bold_font
        ws.cell(row=row_idx, column=5, value=diameter if diameter else 'غير محدد')
        
        row_idx += 2
        
        # Write table headers
        for col_num, header_text in enumerate(OUTPUT_HEADERS, start=1):
            cell = ws.cell(row=row_idx, column=col_num, value=header_text)
            cell.font = bold_font
            cell.alignment = Alignment(horizontal='center')
            cell.border = thin_border
        
        if enable_ai:
            ai_header_cell = ws.cell(row=row_idx, column=len(OUTPUT_HEADERS) + 1, value='ملاحظات الذكاء الاصطناعي')
            ai_header_cell.font = bold_font
            ai_header_cell.alignment = Alignment(horizontal='center')
            ai_header_cell.border = thin_border
        
        row_idx += 1
        
        points_to_write = []
        numeric_data = []
        
        for p in part.get('points', []):
            rtv_old = p.get('RTV_old')
            coth_new = p.get('Coth_new')
            thme_new = p.get('Thme_new')
            
            rtv_new = compute_rtv_new(thme_new, coth_new, factor=rtv_factor)
            cr = compute_cr(rtv_old, rtv_new)
            
            numeric_data.append({
                'COth_new': coth_new,
                'THme_new': thme_new,
                'RTV_old': rtv_old,
                'RTV_new': rtv_new,
                'CR': cr,
            })
            
            points_to_write.append({
                'label': p.get('label'),
                'Coth_new': coth_new,
                'Thme_new': thme_new,
                'RTV_old': rtv_old,
                'RTV_new': rtv_new,
                'CR': cr,
            })
            
        log_callback(f'Found {len(points_to_write)} data points.')
        
        # Anomaly detection
        anomaly_mask = np.array([False] * len(numeric_data))
        if enable_ai and len(numeric_data) > 1:
            df_numeric = pd.DataFrame(numeric_data)
            anomaly_mask = detect_anomalies(df_numeric)
            anomalies_count = np.sum(anomaly_mask)
            if anomalies_count > 0:
                log_callback(f'✨ AI enabled: Found {anomalies_count} anomalies!')
            else:
                log_callback('✨ AI enabled: No anomalies found.')
        
        # Write data to table
        for j, point in enumerate(points_to_write):
            ws.cell(row=row_idx, column=1, value=point['label']).border = thin_border
            ws.cell(row=row_idx, column=2, value=point['Coth_new']).border = thin_border
            ws.cell(row=row_idx, column=3, value=point['Thme_new']).border = thin_border
            ws.cell(row=row_idx, column=4, value=point['RTV_new']).border = thin_border
            ws.cell(row=row_idx, column=5, value=point['RTV_old']).border = thin_border
            ws.cell(row=row_idx, column=6, value=point['CR']).border = thin_border
            
            if enable_ai and anomaly_mask[j]:
                ws.cell(row=row_idx, column=len(OUTPUT_HEADERS) + 1, value='قيمة شاذة').font = Font(color="FF0000")
            
            row_idx += 1
        
        # Add notes
        if part.get('notes'):
            row_idx += 1
            ws.cell(row=row_idx, column=1, value='الملاحظات:').font = bold_font
            notes_text = '\n'.join(part.get('notes'))
            note_cell = ws.cell(row=row_idx, column=2, value=notes_text)
            note_cell.alignment = Alignment(wrap_text=True, vertical='top')
            ws.merge_cells(start_row=row_idx, start_column=2, end_row=row_idx, end_column=len(OUTPUT_HEADERS) + 1)
            row_idx += 1
        
        # Add visual separator
        row_idx += 2
        
    # Adjust column widths
    for col in range(1, len(OUTPUT_HEADERS) + 2):
        ws.column_dimensions[get_column_letter(col)].width = 25
        
    try:
        wb.save(output_path)
    except Exception as e:
        raise IOError(f'Failed to save file: {e}')
    
    return output_path

# ------------------ User Interface (Arabic) ------------------

class CorrosionApp(tk.Tk):
    def __init__(self):
        super().__init__()
        self.title('حاسبة معدل التآكل — نسخة متطورة')
        self.geometry('1000x700')
        
        self.input_path = tk.StringVar()
        self.output_path = tk.StringVar()
        self.rtv_factor = tk.DoubleVar(value=DEFAULT_RTV_FACTOR)
        self.enable_ai = tk.BooleanVar(value=True)
        
        self.notebook = ttk.Notebook(self)
        self.notebook.pack(fill='both', expand=True, padx=15, pady=15)
        
        self.create_main_tab()
        self.create_instructions_tab()
    
    def create_main_tab(self):
        main_tab = ttk.Frame(self.notebook, padding=(10, 10))
        self.notebook.add(main_tab, text='الحاسبة')
        
        # Files Frame
        file_frame = ttk.LabelFrame(main_tab, text='اختيار ملفات الإدخال والإخراج', padding=(10, 10))
        file_frame.pack(fill='x', pady=10)
        
        ttk.Label(file_frame, text='مسار ملف الإدخال (Excel):').grid(row=0, column=0, sticky='w', padx=5, pady=5)
        ttk.Entry(file_frame, textvariable=self.input_path, width=80).grid(row=0, column=1, padx=5, pady=5)
        ttk.Button(file_frame, text='تصفح...', command=self.select_input).grid(row=0, column=2, padx=5, pady=5)
        
        ttk.Label(file_frame, text='مسار ملف الإخراج (Excel):').grid(row=1, column=0, sticky='w', padx=5, pady=5)
        ttk.Entry(file_frame, textvariable=self.output_path, width=80).grid(row=1, column=1, padx=5, pady=5)
        ttk.Button(file_frame, text='تصفح...', command=self.select_output).grid(row=1, column=2, padx=5, pady=5)
        
        # Settings Frame
        settings_frame = ttk.LabelFrame(main_tab, text='إعدادات المعالجة', padding=(10, 10))
        settings_frame.pack(fill='x', pady=10)
        
        ttk.Label(settings_frame, text='عامل RTV (RTV Factor):').grid(row=0, column=0, sticky='w', padx=5, pady=5)
        ttk.Entry(settings_frame, textvariable=self.rtv_factor, width=15).grid(row=0, column=1, padx=5, pady=5)
        
        if HAS_SK:
            ttk.Checkbutton(settings_frame, text='تفعيل الذكاء الاصطناعي للكشف عن القيم الشاذة', variable=self.enable_ai).grid(row=1, column=0, columnspan=4, sticky='w', padx=5, pady=5)
        else:
            ttk.Label(settings_frame, text='⚠️ لا يمكن تفعيل الذكاء الاصطناعي. قم بتثبيت scikit-learn.').grid(row=1, column=0, columnspan=4, sticky='w', padx=5, pady=5)
            self.enable_ai.set(False)
            
        # Action Buttons
        action_frame = ttk.Frame(main_tab)
        action_frame.pack(fill='x', pady=10)
        ttk.Button(action_frame, text='معاينة الملف', command=self.preview_input).pack(side='left', padx=10, ipady=5)
        ttk.Button(action_frame, text='تشغيل وحفظ النتائج', command=self.run_processing).pack(side='left', padx=10, ipady=5)
        ttk.Button(action_frame, text='إغلاق', command=self.quit).pack(side='right', padx=10, ipady=5)
        
        # Log Panel
        log_frame = ttk.LabelFrame(main_tab, text='سجل العمليات والتقارير', padding=(10, 10))
        log_frame.pack(fill='both', expand=True, pady=10)
        
        self.txt = tk.Text(log_frame, wrap='word', height=15, state='disabled', font=('Courier New', 10))
        self.txt.pack(fill='both', expand=True)
        
        self.log_message('مرحباً بك في حاسبة معدل التآكل. ابدأ باختيار ملف الإدخال ثم ملف الإخراج.')

    def create_instructions_tab(self):
        instructions_tab = ttk.Frame(self.notebook, padding=(10, 10))
        self.notebook.add(instructions_tab, text='التعليمات')
        
        instructions_text = tk.Text(instructions_tab, wrap='word', font=('Courier New', 10), state='disabled')
        instructions_text.pack(fill='both', expand=True)
        
        instructions_text.config(state='normal')
        
        # Use a more compatible way to style fonts
        instructions_text.tag_configure('title', font='TkDefaultFont 14 bold')
        instructions_text.tag_configure('section', font='TkDefaultFont 12 bold')

        instructions_text.insert('end', ' دليل استخدام حاسبة معدل التآكل \n', 'title')
        instructions_text.insert('end', '---------------------------------------\n\n')
        
        instructions_text.insert('end', '1. تنسيق ملف الإدخال \n', 'section')
        instructions_text.insert('end', 'يجب أن يكون ملف الإدخال بتنسيق Excel (.xlsx) ومنظماً بشكل محدد. كل جزء أو أنبوب يجب أن يبدأ بصف يحتوي على اسمه وقطره (مثال: "أنبوب الدخول الرئيسي من النهر (المصدر الاول) 12""). بعد ذلك، يجب أن تأتي البيانات في صفوف، مع وجود رؤوس أعمدة محددة.\n\n')
        
        if HAS_TABULATE:
            headers_table = [['رأس العمود', 'البيانات التي يمثلها'],
                             ['Coth_new (μm)', 'قيمة الطلاء الجديدة'],
                             ['Thme_new(mm)', 'قيمة السمك الجديدة'],
                             ['RTV (mm)', 'قيمة RTV القديمة'],
                             ['Notes', 'الملاحظات']]
            table_str = tabulate(headers_table, headers='firstrow', tablefmt='pipe', numalign='center', stralign='right')
            instructions_text.insert('end', '  - رؤوس الأعمدة المطلوبة في الإدخال:\n')
            instructions_text.insert('end', table_str + '\n\n')
        else:
            instructions_text.insert('end', '  - رؤوس الأعمدة المطلوبة في الإدخال:\n')
            instructions_text.insert('end', '  - Coth_new (μm)\n')
            instructions_text.insert('end', '  - Thme_new(mm)\n')
            instructions_text.insert('end', '  - RTV (mm) (القيمة القديمة)\n')
            instructions_text.insert('end', '  - Notes (لإضافة الملاحظات)\n\n')
            
        instructions_text.insert('end', '2. الحسابات في البرنامج \n', 'section')
        instructions_text.insert('end', 'يقوم البرنامج بحساب القيم التالية تلقائيًا:\n\n')
        
        instructions_text.insert('end', '  - حساب RTV الجديدة (RTV (mm))\n')
        instructions_text.insert('end', '    * المعادلة: $RTV (mm) = Thme_{new} - (2.331 \times Coth_{new} \times 0.001)$\n\n')
        
        instructions_text.insert('end', '  - حساب معدل التآكل (CR (mm))\n')
        instructions_text.insert('end', '    * المعادلة: $CR (mm) = RTV_{old} - RTV_{new}$\n\n')
        
        instructions_text.insert('end', '3. تنسيق ملف الإخراج \n', 'section')
        instructions_text.insert('end', 'سيتم إنشاء ملف Excel جديد بالتنسيق التالي لكل جزء:\n')
        instructions_text.insert('end', '  - أولاً: اسم الجزء وقطره.\n')
        instructions_text.insert('end', '  - ثانياً: جدول بالبيانات المحسوبة (التي تتضمن رؤوس الأعمدة التالية):\n')
        
        if HAS_TABULATE:
            output_headers_table = [['رأس العمود', 'البيانات التي يمثلها'],
                                    ['Points', 'رقم النقطة'],
                                    ['COth (mm)', 'قيمة الطلاء الجديدة'],
                                    ['THme (mm)', 'قيمة السمك الجديدة'],
                                    ['RTV (mm)', 'قيمة RTV المحسوبة'],
                                    ['OL (mm)', 'قيمة RTV القديمة من الإدخال'],
                                    ['CR (mm)', 'معدل التآكل المحسوب']]
            table_str = tabulate(output_headers_table, headers='firstrow', tablefmt='pipe', numalign='center', stralign='right')
            instructions_text.insert('end', table_str + '\n\n')
        else:
            instructions_text.insert('end', '  - Points\n  - COth (mm)\n  - THme (mm)\n  - RTV (mm)\n  - OL (mm)\n  - CR (mm)\n\n')
        
        instructions_text.insert('end', '  - ثالثاً: الملاحظات الموجودة في ملف الإدخال.\n')
        
        instructions_text.config(state='disabled')

    def log_message(self, msg):
        """
        Adds a new message to the log panel with a timestamp.
        """
        timestamp = datetime.datetime.now().strftime('%H:%M:%S')
        log_entry = f'[{timestamp}] {msg}\n'
        self.txt.config(state='normal')
        self.txt.insert('end', log_entry)
        self.txt.see('end')
        self.txt.config(state='disabled')

    def select_input(self):
        p = filedialog.askopenfilename(title='اختيار ملف الإدخال', filetypes=[('Excel files', '*.xlsx;*.xls')])
        if p:
            self.input_path.set(p)
            self.log_message(f'✅ تم اختيار ملف الإدخال بنجاح: {Path(p).name}')
            
    def select_output(self):
        p = filedialog.asksaveasfilename(title='اختيار ملف الإخراج', defaultextension='.xlsx', filetypes=[('Excel files', '*.xlsx')])
        if p:
            self.output_path.set(p)
            self.log_message(f'✅ تم اختيار مسار الإخراج: {Path(p).name}')

    def preview_input(self):
        p = self.input_path.get().strip()
        if not p:
            messagebox.showwarning('تحذير', 'الرجاء اختيار ملف إدخال أولاً.')
            return
        
        self.log_message('⚠️ جاري معاينة الملف. هذه العملية لا تحفظ أي شيء.')
        try:
            xls = pd.read_excel(p, sheet_name=None, header=None, dtype=str)
            self.log_message(f'✅ تم فتح الملف: {Path(p).name} بنجاح.')
            for sheet_name, df in xls.items():
                self.log_message(f'   - ورقة العمل: "{sheet_name}" بأبعاد {df.shape[0]} صف و {df.shape[1]} عمود.')
        except Exception as e:
            messagebox.showerror('خطأ في المعاينة', f'حدث خطأ: {e}')
            self.log_message(f'❌ فشلت المعاينة: {e}')
            
    def run_processing(self):
        inp = self.input_path.get().strip()
        outp = self.output_path.get().strip()
        
        if not inp:
            messagebox.showwarning('تحذير', 'يجب اختيار ملف إدخال.')
            return
        
        if not outp:
            inp_path = Path(inp)
            outp = str(inp_path.with_name(f'{inp_path.stem}_results.xlsx'))
            self.output_path.set(outp)
            self.log_message(f'❗ لم يتم تحديد ملف إخراج. سيتم الحفظ تلقائيًا في: {Path(outp).name}')
            
        try:
            self.log_message('🚀 بدء المعالجة... قد يستغرق الأمر بعض الوقت.')
            self.log_message('---------------------------------------')
            
            process_excel_file(
                input_path=inp,
                output_path=outp,
                rtv_factor=self.rtv_factor.get(),
                enable_ai=self.enable_ai.get(),
                log_callback=self.log_message
            )
            
            self.log_message('---------------------------------------')
            self.log_message(f'✅ اكتملت المعالجة بنجاح. تم حفظ النتائج في: {Path(outp).name}')
            messagebox.showinfo('نجاح', f'اكتملت المعالجة. تم حفظ النتائج في:\n{outp}')
            
        except Exception as e:
            messagebox.showerror('خطأ في المعالجة', f'حدث خطأ غير متوقع: {e}')
            self.log_message(f'❌ فشلت المعالجة: {e}')

if __name__ == '__main__':
    app = CorrosionApp()
    app.mainloop()
