# corrosion_tk_app.py
# Tkinter app for parsing your Excel format, computing RTV & CR, smart "جديد" handling,
# simple AI: anomaly detection (IsolationForest) + keyword summary for notes.
#
# Usage: python corrosion_tk_app.py
#
# Author: autogenerated for your request. Adjust paths / options inside GUI.

import tkinter as tk
from tkinter import ttk, filedialog, messagebox
import pandas as pd
import numpy as np
import re
from pathlib import Path
from openpyxl import Workbook
from openpyxl.styles import Alignment
import os

# Optional nicer Arabic rendering (try import; if not available, continue)
try:
    import arabic_reshaper
    from bidi.algorithm import get_display
    def reshape_ar(text):
        try:
            return get_display(arabic_reshaper.reshape(str(text)))
        except:
            return str(text)
except Exception:
    def reshape_ar(text):
        return str(text)

# Optional ML anomaly detector
try:
    from sklearn.ensemble import IsolationForest
    HAS_ISO = True
except Exception:
    HAS_ISO = False

# -------------------------
# Default formulas (can be edited in GUI)
# RTV = Thme - (2.331 * COth * 0.001)
# CR  = Old_Thickness - RTV_new
# -------------------------

DEFAULT_RTV_FACTOR = 2.331
DEFAULT_RTV_CONV = 0.001  # μm -> mm conversion factor used in formula

# -------------------------
# Heuristics / parsing utilities
# -------------------------
PART_KEYWORDS = ['انبوب', 'أنبوب', 'محطة', 'Part', 'POINTS', 'Points', 'Points COth', 'tube', 'line']

def looks_like_part_title(s: str) -> bool:
    if not isinstance(s, str):
        return False
    s = s.strip()
    if len(s) < 3:
        return False
    for kw in PART_KEYWORDS:
        if kw in s:
            return True
    # also if string contains Arabic words and not many digits -> likely title
    if re.search(r'[اأإء-ي]', s) and not re.search(r'\d{2,}', s):
        return True
    return False

def extract_blocks_from_sheet(df: pd.DataFrame):
    """
    Return list of blocks: each block = {'title': title_text, 'lines': [(idx, rowlist, rowtext), ...]}
    A block starts when a row looks like a part title.
    """
    blocks = []
    current = None
    for idx, row in df.iterrows():
        # compose textual content of row
        rowvals = [str(x).strip() if pd.notna(x) else "" for x in row.tolist()]
        row_text = ' '.join([v for v in rowvals if v != ""]).strip()
        if row_text == "":
            # keep blank lines inside block to preserve separation
            if current:
                current['lines'].append((idx, rowvals, row_text))
            continue
        if looks_like_part_title(row_text):
            # start new block
            if current:
                blocks.append(current)
            current = {'title_row': idx, 'title': row_text, 'lines': []}
        else:
            if current:
                current['lines'].append((idx, rowvals, row_text))
            else:
                # skip until first title
                continue
    if current:
        blocks.append(current)
    return blocks

def parse_block_lines(block):
    """
    From lines extract:
    - parsed point rows: detect 'Point' lines with numbers (sequence can vary)
    - notes (lines after 'Notes' or 'ملاحظات' or last lines that look textual)
    - detect 'جديد' marker for point or part
    Return dict: {'title':..., 'points':[{'label':..., 'nums':[...], 'is_new':bool, 'raw':[...]}, ...], 'notes':[...] }
    """
    lines = block['lines']
    parsed_points = []
    notes = []
    capture_notes = False
    for idx, rowvals, rowtext in lines:
        text = rowtext.strip()
        if text == "":
            # skip pure blank
            continue
        # if row starts with notes indicator -> rest are notes
        if re.match(r'^(Notes[:\s]*|ملاحظات[:\s]*|ملاحظات\b)', text, flags=re.I):
            capture_notes = True
            continue
        if capture_notes:
            # collect textual notes lines
            # join rowvals non-empty
            vals = [v for v in rowvals if v not in (None, "", "nan", "NaN")]
            if vals:
                notes.append(' '.join(vals))
            continue
        # otherwise, attempt to detect point row (contains 'Point' or many numbers)
        # gather tokens
        tokens = [t for t in rowvals if str(t).strip() != ""]
        if len(tokens) == 0:
            continue
        t_join = ' '.join([str(t) for t in tokens])
        # detect 'جديد' anywhere
        is_new = any('جديد' in str(t) for t in tokens)
        # find numbers (ints or floats)
        numbers = re.findall(r'[\d]+(?:\.\d+)?', t_join)
        # detect point label: token containing 'Point' or starts with 'Point' or 'Point 1' or Arabic 'نقطة'
        point_label = ""
        for t in tokens[:3]:
            if re.search(r'Point\s*\d+|Point', str(t), flags=re.I) or re.search(r'نقطة|نق', str(t)):
                point_label = str(t)
                break
        # if no explicit label, maybe first token is name like 'Point 1' merged or 'Point 1 45 203 ...' -> t_join may have 'Point 1'
        m = re.search(r'(Point\s*\d+)', t_join, flags=re.I)
        if not point_label and m:
            point_label = m.group(1)
        # fallback: if first token not numeric, use it as label
        if not point_label:
            if not re.match(r'^[\d\.\-]+$', str(tokens[0])):
                point_label = str(tokens[0])
        # finally, if there are at least 2 numbers or 3 or 4, accept as data row
        if len(numbers) >= 1:
            parsed_points.append({'label': point_label, 'nums': numbers, 'is_new': is_new, 'raw_tokens': tokens})
        else:
            # if not numbers, probably a stray text line -> consider as note
            notes.append(t_join)
    return {'title': block['title'], 'points': parsed_points, 'notes': notes}

# map numbers into expected columns
def map_nums_sequence(nums):
    """
    Based on your description: sequence is [COth_old, COth_new, Thme_old, Thme_new]
    but files may present 2..4 numbers; handle variants:
    if len==4 -> map as above
    if len==3 -> [COth_old, COth_new, Thme_new]
    if len==2 -> [COth_new, Thme_new]
    if len==1 -> [Thme_new]
    """
    mapping = {'COth_old': None, 'COth_new': None, 'Thme_old': None, 'Thme_new': None}
    if len(nums) >= 4:
        mapping['COth_old'] = nums[0]
        mapping['COth_new'] = nums[1]
        mapping['Thme_old'] = nums[2]
        mapping['Thme_new'] = nums[3]
    elif len(nums) == 3:
        mapping['COth_old'] = nums[0]
        mapping['COth_new'] = nums[1]
        mapping['Thme_new'] = nums[2]
    elif len(nums) == 2:
        mapping['COth_new'] = nums[0]
        mapping['Thme_new'] = nums[1]
    elif len(nums) == 1:
        mapping['Thme_new'] = nums[0]
    return mapping

# compute RTV using formula
def compute_rtv(thme_val, coth_val, factor=DEFAULT_RTV_FACTOR, conv=DEFAULT_RTV_CONV):
    try:
        th = float(thme_val)
        co = float(coth_val)
        return th - (factor * co * conv)
    except Exception:
        return None

# compute CR per your request: CR = Old_Thickness - RTV_new
def compute_cr(old_thickness_val, rtv_new_val):
    try:
        if old_thickness_val is None or rtv_new_val is None:
            return None
        return float(old_thickness_val) - float(rtv_new_val)
    except Exception:
        return None

# notes keyword summarizer (very simple)
NOTES_KEYWORDS = {
    'مساند': 'تآكل في المساند',
    'تآكل': 'تآكل عام',
    'طلاء': 'حاجة لإعادة طلاء',
    'اتصال مباشر': 'اتصال مباشر مع الانبوب',
    'تسريب': 'احتمال وجود تسريب',
    'تنظيف': 'حاجة لتنظيف المنطقة'
}

def summarize_notes(note_lines):
    s = ' '.join(note_lines)
    summary = []
    for k, v in NOTES_KEYWORDS.items():
        if k in s:
            summary.append(v)
    if not summary and s.strip():
        # fallback: return first 120 chars
        return s.strip()[:250]
    return '; '.join(sorted(set(summary)))

# Anomaly detection (IsolationForest) wrapper
def detect_anomalies_numeric(df_numeric):
    """
    df_numeric: pandas DataFrame of numeric columns e.g. [RTV_new, Thme_new, COth_new]
    Returns boolean mask (True for anomaly)
    """
    if not HAS_ISO:
        return np.array([False]*len(df_numeric))
    try:
        iso = IsolationForest(n_estimators=100, contamination=0.05, random_state=42)
        X = df_numeric.fillna(df_numeric.mean()).values
        preds = iso.fit_predict(X)  # -1 anomaly, 1 normal
        return (preds == -1)
    except Exception:
        return np.array([False]*len(df_numeric))

# -------------------------
# Core processing for a file
# -------------------------
def process_excel_file(input_path: str,
                       output_path: str,
                       rtv_factor: float = DEFAULT_RTV_FACTOR,
                       rtv_conv: float = DEFAULT_RTV_CONV,
                       enable_anomaly_detection: bool = False):
    """
    Read Excel (all sheets), detect blocks, parse, compute RTV/CR and write a processed Excel with layout:
    Title (merged) then rows:
    Point | COth_old (μm) | COth_new (μm) | Thme_old (mm) | Thme_new (mm) | RTV_old (mm) | RTV_new (mm) | CR (mm)
    Notes under each block.
    """
    inp = Path(input_path)
    if not inp.exists():
        raise FileNotFoundError(f"Input not found: {input_path}")
    xls = pd.read_excel(inp, sheet_name=None, header=None, dtype=str)
    parts = []
    # parse sheets
    for sheet_name, df in xls.items():
        blocks = extract_blocks_from_sheet(df)
        for b in blocks:
            parsed = parse_block_lines(b)
            parts.append(parsed)

    # Build output workbook
    wb = Workbook()
    ws = wb.active
    ws.title = "Processed"
    row_cursor = 1

    # For anomaly detection: collect numeric df for all points (we'll detect per part)
    for part in parts:
        title = part['title']
        # write title merged across 9 columns
        ws.merge_cells(start_row=row_cursor, start_column=1, end_row=row_cursor, end_column=9)
        ws.cell(row=row_cursor, column=1, value=title)
        ws.cell(row=row_cursor, column=1).alignment = Alignment(horizontal='center')
        row_cursor += 1
        headers = ['Point', 'COth_old (μm)', 'COth_new (μm)', 'Thme_old (mm)', 'Thme_new (mm)',
                   'RTV_old (mm)', 'RTV_new (mm)', 'CR (mm)', 'NoteFlag']
        for c, h in enumerate(headers, start=1):
            ws.cell(row=row_cursor, column=c, value=h)
        row_cursor += 1

        # collect numeric rows for potential anomaly detection
        numeric_rows = []
        points_meta = []

        for p in part['points']:
            mapping = map_nums_sequence(p['nums'])
            # compute RTVs using mapping and provided formula
            rtv_old = None
            rtv_new = None
            if mapping.get('Thme_old') and mapping.get('COth_old'):
                rtv_old = compute_rtv(mapping['Thme_old'], mapping['COth_old'], factor=rtv_factor, conv=rtv_conv)
            if mapping.get('Thme_new') and mapping.get('COth_new'):
                rtv_new = compute_rtv(mapping['Thme_new'], mapping['COth_new'], factor=rtv_factor, conv=rtv_conv)
            # decide old_thickness value (if exists) for CR computation: use Thme_old if present
            old_thickness_val = mapping.get('Thme_old') or mapping.get('RTV_old') if mapping.get('RTV_old') else None
            cr = None
            # if point or full part marked 'جديد', skip CR and drop old thickness
            if p.get('is_new'):
                rtv_old = None
                cr = None
            else:
                # CR = Old_Thickness - RTV_new if we have old_thickness
                if mapping.get('Thme_old') and rtv_new is not None:
                    cr = compute_cr(mapping.get('Thme_old'), rtv_new)

            # store numeric set for anomaly detection
            numeric_rows.append({'RTV_new': rtv_new, 'Thme_new': mapping.get('Thme_new'), 'COth_new': mapping.get('COth_new')})
            points_meta.append({'label': p.get('label'), 'COth_old': mapping.get('COth_old'),
                                'COth_new': mapping.get('COth_new'),
                                'Thme_old': mapping.get('Thme_old'),
                                'Thme_new': mapping.get('Thme_new'),
                                'RTV_old': rtv_old, 'RTV_new': rtv_new, 'CR': cr, 'is_new': p.get('is_new')})

        # detect anomalies if enabled
        anomaly_mask = None
        if enable_anomaly_detection and HAS_ISO and len(numeric_rows) > 1:
            dfnum = pd.DataFrame(numeric_rows).astype(float)
            # fill NA with mean temporarily
            dfnum_filled = dfnum.fillna(dfnum.mean())
            try:
                mask = detect_anomalies_numeric(dfnum_filled)
                anomaly_mask = mask
            except Exception:
                anomaly_mask = np.array([False]*len(numeric_rows))
        else:
            anomaly_mask = np.array([False]*len(numeric_rows))

        # write rows to sheet
        for i, meta in enumerate(points_meta):
            row_vals = [
                meta.get('label'),
                meta.get('COth_old'),
                meta.get('COth_new'),
                meta.get('Thme_old'),
                meta.get('Thme_new'),
                meta.get('RTV_old'),
                meta.get('RTV_new'),
                meta.get('CR'),
                'ANOMALY' if anomaly_mask[i] else ('NEW' if meta.get('is_new') else '')
            ]
            for c, v in enumerate(row_vals, start=1):
                ws.cell(row=row_cursor, column=c, value=(None if v in (None, '', 'nan') else v))
            row_cursor += 1

        # write notes summary
        if part.get('notes'):
            ws.cell(row=row_cursor, column=1, value="Notes:")
            ws.merge_cells(start_row=row_cursor, start_column=2, end_row=row_cursor, end_column=9)
            summarized = summarize_notes(part.get('notes'))
            ws.cell(row=row_cursor, column=2, value=summarized)
            row_cursor += 2
        else:
            row_cursor += 1

    # save workbook
    wb.save(output_path)
    return output_path

# -------------------------
# Tkinter GUI
# -------------------------
class CorrosionApp(tk.Tk):
    def __init__(self):
        super().__init__()
        self.title(reshape_ar("حاسبة معدل التآكل — Corrosion Processor"))
        self.geometry("920x620")
        self.configure(padx=10, pady=10)
        # variables
        self.input_path = tk.StringVar()
        self.output_path = tk.StringVar()
        self.rtv_factor = tk.DoubleVar(value=DEFAULT_RTV_FACTOR)
        self.rtv_conv = tk.DoubleVar(value=DEFAULT_RTV_CONV)
        self.enable_anomaly = tk.BooleanVar(value=False)
        # UI
        self.create_widgets()

    def create_widgets(self):
        frm_top = ttk.Frame(self)
        frm_top.pack(fill='x', pady=6)

        ttk.Label(frm_top, text=reshape_ar("ملف الإدخال (Excel):")).grid(row=0, column=0, sticky='w')
        ent_input = ttk.Entry(frm_top, textvariable=self.input_path, width=70)
        ent_input.grid(row=0, column=1, padx=6)
        ttk.Button(frm_top, text=reshape_ar("اختيار"), command=self.select_input).grid(row=0, column=2, padx=4)

        ttk.Label(frm_top, text=reshape_ar("ملف الإخراج (Excel):")).grid(row=1, column=0, sticky='w', pady=6)
        ent_out = ttk.Entry(frm_top, textvariable=self.output_path, width=70)
        ent_out.grid(row=1, column=1, padx=6, pady=6)
        ttk.Button(frm_top, text=reshape_ar("اختيار"), command=self.select_output).grid(row=1, column=2, padx=4)

        # settings frame
        frm_settings = ttk.LabelFrame(self, text=reshape_ar("إعدادات الصيغ والذكاء"))
        frm_settings.pack(fill='x', pady=8)

        ttk.Label(frm_settings, text=reshape_ar("عامل RTV (مثال 2.331):")).grid(row=0, column=0, sticky='w', padx=6, pady=4)
        ttk.Entry(frm_settings, textvariable=self.rtv_factor, width=12).grid(row=0, column=1, sticky='w')
        ttk.Label(frm_settings, text=reshape_ar("عامل تحويل μm→mm:")).grid(row=0, column=2, sticky='w', padx=6)
        ttk.Entry(frm_settings, textvariable=self.rtv_conv, width=8).grid(row=0, column=3, sticky='w')

        ttk.Checkbutton(frm_settings, text=reshape_ar("تفعيل كشف الشذوذ (IsolationForest) [اختياري]"),
                        variable=self.enable_anomaly).grid(row=1, column=0, columnspan=4, sticky='w', padx=6, pady=4)

        # action buttons
        frm_actions = ttk.Frame(self)
        frm_actions.pack(fill='x', pady=10)
        ttk.Button(frm_actions, text=reshape_ar("معاينة الملف"), command=self.preview_input).pack(side='left', padx=6)
        ttk.Button(frm_actions, text=reshape_ar("تشغيل الحسابات وحفظ"), command=self.run_processing).pack(side='left', padx=6)
        ttk.Button(frm_actions, text=reshape_ar("إغلاق"), command=self.quit).pack(side='right', padx=6)

        # preview area
        frm_preview = ttk.LabelFrame(self, text=reshape_ar("معاينة/سجل العمليات"))
        frm_preview.pack(fill='both', expand=True, pady=6)
        self.txt = tk.Text(frm_preview, wrap='word')
        self.txt.pack(fill='both', expand=True)
        self.log(reshape_ar("مرحباً — اختر ملف الإدخال ثم ملف الإخراج، ثم اضغط 'تشغيل الحسابات وحفظ'."))

    def log(self, msg):
        self.txt.insert('end', str(msg) + '\n')
        self.txt.see('end')

    def select_input(self):
        p = filedialog.askopenfilename(filetypes=[("Excel files", "*.xlsx *.xls")])
        if p:
            self.input_path.set(p)
            self.log(reshape_ar(f"تم اختيار ملف الإدخال: {p}"))

    def select_output(self):
        p = filedialog.asksaveasfilename(defaultextension=".xlsx", filetypes=[("Excel files", "*.xlsx")])
        if p:
            self.output_path.set(p)
            self.log(reshape_ar(f"تم اختيار ملف الإخراج: {p}"))

    def preview_input(self):
        p = self.input_path.get().strip()
        if not p:
            messagebox.showwarning("Warning", reshape_ar("اختر ملف الإدخال أولاً."))
            return
        try:
            xls = pd.read_excel(p, sheet_name=None, header=None, dtype=str)
            # show sheet names and first few non-empty lines
            self.log(reshape_ar(f"فتح الملف: {p} - الأوراق: {', '.join(xls.keys())}"))
            for name, df in xls.items():
                self.log(reshape_ar(f"ورقة: {name} - الأبعاد: {df.shape}"))
                # show first 8 non-empty rows
                shown = 0
                for idx, row in df.iterrows():
                    rowvals = [str(x).strip() if pd.notna(x) else "" for x in row.tolist()]
                    row_text = ' '.join([v for v in rowvals if v != ""]).strip()
                    if row_text:
                        self.log(row_text)
                        shown += 1
                        if shown >= 6:
                            break
        except Exception as e:
            messagebox.showerror("Error", str(e))

    def run_processing(self):
        inp = self.input_path.get().strip()
        outp = self.output_path.get().strip()
        if not inp:
            messagebox.showwarning("Warning", reshape_ar("اختر ملف الإدخال أولاً."))
            return
        if not outp:
            # auto-generate output path next to input
            inp_path = Path(inp)
            outp = str(inp_path.with_name(inp_path.stem + "_processed.xlsx"))
            self.output_path.set(outp)
            self.log(reshape_ar(f"لم يتم اختيار ملف إخراج، تم توليد المسار: {outp}"))
        try:
            self.log(reshape_ar("ابدأ المعالجة..."))
            res_path = process_excel_file(inp, outp, rtv_factor=self.rtv_factor.get(),
                                          rtv_conv=self.rtv_conv.get(),
                                          enable_anomaly_detection=self.enable_anomaly.get())
            self.log(reshape_ar(f"اكتملت المعالجة، تم حفظ الملف: {res_path}"))
            messagebox.showinfo("Done", reshape_ar(f"تم الحفظ: {res_path}"))
        except Exception as e:
            messagebox.showerror("Error", str(e))
            self.log("Error: " + str(e))

if __name__ == "__main__":
    app = CorrosionApp()
    app.mainloop()
