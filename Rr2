#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
enhanced_corrosion_tk_app.py

Ø¨Ø±Ù†Ø§Ù…Ø¬ Ù…ØªØ·ÙˆØ± ÙˆÙ…Ø­Ø³Ù† Ù„Ø­Ø³Ø§Ø¨ Ù…Ø¹Ø¯Ù„ Ø§Ù„ØªØ¢ÙƒÙ„ Ù…Ù† Ø¨ÙŠØ§Ù†Ø§Øª Excel.
ÙŠØ³ØªØ®Ø¯Ù… ÙˆØ§Ø¬Ù‡Ø© Ù…Ø³ØªØ®Ø¯Ù… Ø¹Ø±Ø¨ÙŠØ© Ù…Ø­Ø³Ù†Ø© Ù…Ø¹ Ø´Ø±ÙŠØ· Ø§Ù„ØªÙ‚Ø¯Ù… ÙˆØ§Ù„Ù…Ø¹Ø§ÙŠÙ†Ø© Ø§Ù„Ù…Ø¨Ø§Ø´Ø±Ø©.
ÙŠØªÙ…ÙŠØ² Ø¨Ø®Ø§ØµÙŠØ© "Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ" Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø© Ù„Ù„ÙƒØ´Ù Ø¹Ù† Ø§Ù„Ù‚ÙŠÙ… Ø§Ù„Ø´Ø§Ø°Ø©.
ÙŠÙ‚ÙˆÙ… Ø¨Ø­ÙØ¸ Ø§Ù„Ù†ØªØ§Ø¦Ø¬ ÙÙŠ Ù…Ù„Ù Ø¥Ø®Ø±Ø§Ø¬ Ø¬Ø¯ÙŠØ¯ Ø¨ØªÙ†Ø³ÙŠÙ‚ Ù…ÙØ­Ø¯Ø¯ ÙˆÙ…Ù†Ø³Ù‚.
"""

import tkinter as tk
from tkinter import ttk, filedialog, messagebox
from pathlib import Path
import pandas as pd
import numpy as np
import re
from openpyxl import Workbook
from openpyxl.styles import Alignment, Font, Border, Side, PatternFill
from openpyxl.utils import get_column_letter
import datetime
import threading
import os
import subprocess
import sys

# Attempt to import scikit-learn for AI features
try:
    from sklearn.ensemble import IsolationForest
    from sklearn.preprocessing import RobustScaler
    HAS_SK = True
except ImportError:
    HAS_SK = False

# Import tabulate for instructions formatting
try:
    from tabulate import tabulate
    HAS_TABULATE = True
except ImportError:
    HAS_TABULATE = False

# ------------------ Constants ------------------
DEFAULT_RTV_FACTOR = 2.331
DEFAULT_RTV_CONV = 0.001

# Keywords for part titles
PART_KEYWORDS = ['"', 'inch', 'in', 'Ø§Ù†Ø´', 'Ø§Ù†Ø¨ÙˆØ¨', 'Ø£Ù†Ø¨ÙˆØ¨', 'Ù…Ø­Ø·Ø©', 'Part', 'POINTS', 'Points', 'tube', 'line']

# Expected headers in the input file
INPUT_HEADERS = ['Coth_old (Î¼m)', 'Coth_new (Î¼m)', 'RTV (mm)', 'Thme_new(mm)']
OUTPUT_HEADERS = ['Points', 'COth (mm)', 'THme (mm)', 'RTV (mm)', 'OL (mm)', 'CR (mm)', 'Ù…Ù„Ø§Ø­Ø¸Ø§Øª Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ']

# ------------------ Data Processing Functions ------------------

def extract_numbers_from_text(s: str):
    """
    Extracts numbers from a string, supporting comma or period as decimal separators.
    """
    if s is None:
        return []
    s2 = str(s).replace('Ù¬', '.').replace(',', '.').replace('Ù«', '.')
    s2 = s2.replace('\xa0', ' ').replace(' ', '')
    nums = re.findall(r'[-+]?\d*\.\d+|[-+]?\d+', s2)
    return nums

def looks_like_part_title(s: str) -> bool:
    """
    Checks if a string looks like a part title based on keywords and numbers.
    """
    if not isinstance(s, str):
        return False
    s = s.strip()
    if len(s) < 2:
        return False
    for kw in PART_KEYWORDS:
        if kw.lower() in s.lower():
            return True
    if re.search(r'[Ø§Ø£Ø¥Ø¡-ÙŠ]', s) and (re.search(r'Ø£Ù†Ø¨ÙˆØ¨|Ø®Ø·|pipe|line', s, flags=re.I) or re.search(r'\d',s)):
        return True
    return False

def extract_blocks_from_sheet(df: pd.DataFrame):
    """
    Parses an Excel sheet into "blocks", where each block represents a part.
    A block starts with a part title and continues until another title or end of sheet.
    """
    blocks = []
    current_block = None
    df = df.fillna('')
   
    for idx, row in df.iterrows():
        row_text = ' '.join([str(x).strip() for x in row.tolist() if str(x).strip() != ""]).strip()
       
        if not row_text and current_block:
            current_block['lines'].append((idx, row.tolist(), row_text))
            continue
       
        if looks_like_part_title(row_text):
            if current_block:
                blocks.append(current_block)
            current_block = {'title_row': idx, 'title': row_text, 'lines': []}
        elif current_block:
            current_block['lines'].append((idx, row.tolist(), row_text))
   
    if current_block:
        blocks.append(current_block)
   
    return blocks

def parse_block_lines(block):
    """
    Parses lines within a block to extract data points and notes.
    """
    points = []
    notes = []
    capture_notes = False
   
    for i, (idx, rowvals, rowtext) in enumerate(block['lines']):
        text_lower = rowtext.lower()
       
        if 'notes' in text_lower or 'Ù…Ù„Ø§Ø­Ø¸Ø§Øª' in text_lower:
            capture_notes = True
            continue
       
        if capture_notes:
            vals = [str(v).strip() for v in rowvals if str(v).strip() != ""]
            if vals:
                notes.append(' '.join(vals))
            continue
       
        tokens = [str(t).strip() for t in rowvals if str(t).strip() != ""]
        if not tokens:
            continue
           
        label_guess = tokens[0]
        t_join = ' '.join(tokens)
        num_strs = extract_numbers_from_text(t_join)
       
        if not num_strs:
            continue
           
        # Check if the row contains the expected number of values
        if len(num_strs) >= 3:
            try:
                # Assuming the order: Coth_new, Thme_new, RTV (old)
                coth_new = float(num_strs[1]) if len(num_strs) > 1 else 0
                thme_new = float(num_strs[2]) if len(num_strs) > 2 else 0
                rtv_old = float(num_strs[3]) if len(num_strs) > 3 else 0
               
                points.append({
                    'label': label_guess,
                    'Coth_new': coth_new,
                    'Thme_new': thme_new,
                    'RTV_old': rtv_old,
                })
            except (ValueError, IndexError):
                # Ignore rows that don't fit the expected format
                pass
   
    return {'title': block.get('title', ''), 'points': points, 'notes': notes}

def compute_rtv_new(thme_val, coth_val, factor=DEFAULT_RTV_FACTOR):
    """
    Calculates the new RTV value based on the formula.
    """
    try:
        if thme_val is None or coth_val is None:
            return None
        th = float(thme_val)
        co = float(coth_val)
        return th - (float(factor) * co * DEFAULT_RTV_CONV)
    except Exception:
        return None

def compute_cr(rtv_old, rtv_new):
    """
    Calculates the Corrosion Rate (CR) from old and new RTV values.
    """
    try:
        if rtv_old is None or rtv_new is None:
            return None
        return float(rtv_old) - float(rtv_new)
    except Exception:
        return None

def extract_diameter_from_title(title: str):
    """
    Extracts the diameter in inches from a part title.
    Example: "Pipe 12 inch" -> "12" or "10\" Line" -> "10"
    """
    if not isinstance(title, str):
        return 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯'
    m = re.search(r"(\d+(?:\.\d+)?)\s*(?:\"|in|inch|inches|Ø§Ù†Ø´)", title, flags=re.I)
    if m:
        return m.group(1)
    m2 = re.search(r'(\d+(?:\.\d+)?)"', title)
    if m2:
        return m2.group(1)
    return 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯'

def detect_anomalies(df_numeric):
    """
    Uses RobustScaler and IsolationForest to detect anomalies.
    """
    if not HAS_SK or df_numeric.empty or len(df_numeric) < 2:
        return np.array([False] * len(df_numeric))
    try:
        X = df_numeric.fillna(df_numeric.mean())
        scaler = RobustScaler()
        Xs = scaler.fit_transform(X)
        iso = IsolationForest(random_state=42, n_estimators=100, contamination='auto')
        preds = iso.fit_predict(Xs)
        return preds == -1
    except Exception:
        return np.array([False] * len(df_numeric))

# ------------------ Main Processing Logic ------------------

def process_excel_file(input_path: str, output_path: str, rtv_factor: float, enable_ai: bool, log_callback=None, progress_callback=None):
    """
    Reads the Excel file, processes the data, and saves the results in a new file.
    """
    if log_callback is None:
        log_callback = print
    if progress_callback is None:
        progress_callback = lambda x: None

    inp = Path(input_path)
    if not inp.exists():
        raise FileNotFoundError(f'Input file not found: {inp}')

    log_callback(f'ğŸ”„ Ø¨Ø¯Ø¡ Ù‚Ø±Ø§Ø¡Ø© Ù…Ù„Ù Ø§Ù„Ø¥Ø¯Ø®Ø§Ù„: {inp.name}...')
    progress_callback(10)
    
    try:
        xls = pd.read_excel(inp, sheet_name=None, header=None, dtype=str)
    except Exception as e:
        raise ValueError(f'Ø®Ø·Ø£ ÙÙŠ Ù‚Ø±Ø§Ø¡Ø© Ù…Ù„Ù Excel: {e}')

    progress_callback(25)
    parts_data = []
    total_sheets = len(xls)
    
    for sheet_idx, (sheet_name, df) in enumerate(xls.items()):
        log_callback(f'ğŸ” ØªØ­Ù„ÙŠÙ„ ÙˆØ±Ù‚Ø© Ø§Ù„Ø¹Ù…Ù„ "{sheet_name}" ({sheet_idx + 1}/{total_sheets})')
        blocks = extract_blocks_from_sheet(df)
        log_callback(f'   âœ… ØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ {len(blocks)} Ø¬Ø²Ø¡ Ù…Ø­ØªÙ…Ù„ ÙÙŠ Ø§Ù„ÙˆØ±Ù‚Ø©')
        
        for i, b in enumerate(blocks):
            parsed = parse_block_lines(b)
            parsed['sheet_name'] = sheet_name
            parts_data.append(parsed)
        
        progress = 25 + (sheet_idx + 1) * 30 / total_sheets
        progress_callback(int(progress))

    if not parts_data:
        raise ValueError('âŒ Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø¨ÙŠØ§Ù†Ø§Øª ØµØ§Ù„Ø­Ø© ÙÙŠ Ø§Ù„Ù…Ù„Ù.')

    progress_callback(60)
    log_callback(f'ğŸ“Š Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ø£Ø¬Ø²Ø§Ø¡ Ø§Ù„Ù…ÙˆØ¬ÙˆØ¯Ø©: {len(parts_data)}')
    log_callback('ğŸ”„ Ø¨Ø¯Ø¡ Ø¥Ù†Ø´Ø§Ø¡ Ù…Ù„Ù Ø§Ù„Ø¥Ø®Ø±Ø§Ø¬...')

    wb = Workbook()
    ws = wb.active
    ws.title = 'Ù†ØªØ§Ø¦Ø¬ Ø­Ø³Ø§Ø¨ Ù…Ø¹Ø¯Ù„ Ø§Ù„ØªØ¢ÙƒÙ„'
    row_idx = 1
   
    # Define styles
    thin_border = Border(left=Side(style='thin'), right=Side(style='thin'), 
                        top=Side(style='thin'), bottom=Side(style='thin'))
    bold_font = Font(bold=True, size=12)
    header_font = Font(bold=True, size=11, color="FFFFFF")
    header_fill = PatternFill(start_color="4472C4", end_color="4472C4", fill_type="solid")
    anomaly_font = Font(color="FF0000", bold=True)
    title_font = Font(bold=True, size=14)
   
    total_parts = len(parts_data)
    
    for part_idx, part in enumerate(parts_data):
        log_callback(f'âš™ï¸ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø¬Ø²Ø¡ ({part_idx + 1}/{total_parts}): "{part.get("title", "Ø¨Ù„Ø§ Ø§Ø³Ù…")}"')
       
        title = part.get('title', 'Ø¬Ø²Ø¡ Ø¨Ù„Ø§ Ø§Ø³Ù…')
        diameter = extract_diameter_from_title(title)
       
        # Write part title and diameter row
        ws.cell(row=row_idx, column=1, value='Ø§Ø³Ù… Ø§Ù„Ø¬Ø²Ø¡:').font = title_font
        ws.cell(row=row_idx, column=2, value=title)
        ws.cell(row=row_idx, column=4, value='Ù‚Ø·Ø±Ù‡ Ø¨Ø§Ù„Ø§Ù†Ø´:').font = title_font
        ws.cell(row=row_idx, column=5, value=diameter)
        
        # Apply borders to the title row
        for col in range(1, 8):
            ws.cell(row=row_idx, column=col).border = thin_border
       
        row_idx += 2
       
        # Write table headers with styling
        for col_num, header_text in enumerate(OUTPUT_HEADERS, start=1):
            cell = ws.cell(row=row_idx, column=col_num, value=header_text)
            cell.font = header_font
            cell.fill = header_fill
            cell.alignment = Alignment(horizontal='center', vertical='center')
            cell.border = thin_border
       
        row_idx += 1
       
        points_to_write = []
        numeric_data = []
       
        # Process each point
        for p in part.get('points', []):
            rtv_old = p.get('RTV_old')
            coth_new = p.get('Coth_new')
            thme_new = p.get('Thme_new')
           
            rtv_new = compute_rtv_new(thme_new, coth_new, factor=rtv_factor)
            cr = compute_cr(rtv_old, rtv_new)
           
            numeric_data.append({
                'COth_new': coth_new,
                'THme_new': thme_new,
                'RTV_old': rtv_old,
                'RTV_new': rtv_new,
                'CR': cr,
            })
           
            points_to_write.append({
                'label': p.get('label'),
                'Coth_new': coth_new,
                'Thme_new': thme_new,
                'RTV_old': rtv_old,
                'RTV_new': rtv_new,
                'CR': cr,
            })
           
        log_callback(f'   ğŸ“ˆ ØªÙ… Ù…Ø¹Ø§Ù„Ø¬Ø© {len(points_to_write)} Ù†Ù‚Ø·Ø© Ø¨ÙŠØ§Ù†Ø§Øª')
       
        # Anomaly detection
        anomaly_mask = np.array([False] * len(numeric_data))
        if enable_ai and len(numeric_data) > 1:
            df_numeric = pd.DataFrame(numeric_data)
            anomaly_mask = detect_anomalies(df_numeric)
            anomalies_count = np.sum(anomaly_mask)
            if anomalies_count > 0:
                log_callback(f'   ğŸ¤– Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ: ØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ {anomalies_count} Ù‚ÙŠÙ… Ø´Ø§Ø°Ø©!')
            else:
                log_callback('   ğŸ¤– Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ: Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ù‚ÙŠÙ… Ø´Ø§Ø°Ø©')
       
        # Write data to table
        for j, point in enumerate(points_to_write):
            # Points column
            ws.cell(row=row_idx, column=1, value=point['label']).border = thin_border
            
            # COth (mm) column
            coth_cell = ws.cell(row=row_idx, column=2, value=point['Coth_new'])
            coth_cell.border = thin_border
            coth_cell.alignment = Alignment(horizontal='center')
            
            # THme (mm) column
            thme_cell = ws.cell(row=row_idx, column=3, value=point['Thme_new'])
            thme_cell.border = thin_border
            thme_cell.alignment = Alignment(horizontal='center')
            
            # RTV (mm) column
            rtv_cell = ws.cell(row=row_idx, column=4, value=point['RTV_new'])
            rtv_cell.border = thin_border
            rtv_cell.alignment = Alignment(horizontal='center')
            
            # OL (mm) column
            ol_cell = ws.cell(row=row_idx, column=5, value=point['RTV_old'])
            ol_cell.border = thin_border
            ol_cell.alignment = Alignment(horizontal='center')
            
            # CR (mm) column
            cr_cell = ws.cell(row=row_idx, column=6, value=point['CR'])
            cr_cell.border = thin_border
            cr_cell.alignment = Alignment(horizontal='center')
           
            # AI Notes column
            ai_notes_cell = ws.cell(row=row_idx, column=7)
            ai_notes_cell.border = thin_border
            if enable_ai and j < len(anomaly_mask) and anomaly_mask[j]:
                ai_notes_cell.value = 'Ù‚ÙŠÙ…Ø© Ø´Ø§Ø°Ø©'
                ai_notes_cell.font = anomaly_font
            else:
                ai_notes_cell.value = ''
            ai_notes_cell.alignment = Alignment(horizontal='center')
           
            row_idx += 1
       
        # Add notes if they exist
        if part.get('notes'):
            row_idx += 1
            notes_title_cell = ws.cell(row=row_idx, column=1, value='Ø§Ù„Ù…Ù„Ø§Ø­Ø¸Ø§Øª:')
            notes_title_cell.font = bold_font
            notes_title_cell.border = thin_border
            
            notes_text = '\n'.join(part.get('notes'))
            # Merge cells for notes (from column 2 to 7)
            ws.merge_cells(start_row=row_idx, start_column=2, end_row=row_idx, end_column=7)
            note_cell = ws.cell(row=row_idx, column=2, value=notes_text)
            note_cell.alignment = Alignment(wrap_text=True, vertical='top', horizontal='right')
            note_cell.border = thin_border
            
            # Apply border to all merged cells
            for col in range(2, 8):
                ws.cell(row=row_idx, column=col).border = thin_border
            
            row_idx += 1
       
        # Add visual separator
        row_idx += 2
        
        # Update progress
        progress = 60 + (part_idx + 1) * 30 / total_parts
        progress_callback(int(progress))

    # Adjust column widths for better readability
    column_widths = [15, 20, 20, 20, 20, 20, 25]  # Points, COth, THme, RTV, OL, CR, AI Notes
    for idx, width in enumerate(column_widths, start=1):
        ws.column_dimensions[get_column_letter(idx)].width = width
   
    # Auto-fit row heights
    for row in ws.iter_rows():
        max_height = 15
        for cell in row:
            if cell.value and isinstance(cell.value, str) and '\n' in str(cell.value):
                lines = str(cell.value).count('\n') + 1
                max_height = max(max_height, lines * 15)
        ws.row_dimensions[row[0].row].height = max_height

    progress_callback(95)
    log_callback('ğŸ’¾ Ø­ÙØ¸ Ù…Ù„Ù Ø§Ù„Ø¥Ø®Ø±Ø§Ø¬...')
    
    try:
        wb.save(output_path)
    except Exception as e:
        raise IOError(f'ÙØ´Ù„ ÙÙŠ Ø­ÙØ¸ Ø§Ù„Ù…Ù„Ù: {e}')
   
    progress_callback(100)
    log_callback(f'âœ… ØªÙ… Ø­ÙØ¸ Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ø¨Ù†Ø¬Ø§Ø­ ÙÙŠ: {Path(output_path).name}')
    return output_path

# ------------------ Enhanced User Interface ------------------

class CorrosionApp(tk.Tk):
    def __init__(self):
        super().__init__()
        self.title('ğŸ§ª Ø­Ø§Ø³Ø¨Ø© Ù…Ø¹Ø¯Ù„ Ø§Ù„ØªØ¢ÙƒÙ„ â€” Ø§Ù„Ø¥ØµØ¯Ø§Ø± Ø§Ù„Ù…Ø­Ø³Ù† 2024')
        self.geometry('1200x800')
        self.minsize(1000, 600)
        
        # Configure style
        style = ttk.Style()
        style.theme_use('clam')
        
        # Variables
        self.input_path = tk.StringVar()
        self.output_path = tk.StringVar()
        self.rtv_factor = tk.DoubleVar(value=DEFAULT_RTV_FACTOR)
        self.enable_ai = tk.BooleanVar(value=True)
        self.processing = False
        
        # Auto-set output path when input changes
        self.input_path.trace('w', self.auto_set_output_path)
        
        # Create UI
        self.create_ui()
        
        # Center window
        self.center_window()
   
    def center_window(self):
        """Centers the window on screen"""
        self.update_idletasks()
        width = self.winfo_width()
        height = self.winfo_height()
        x = (self.winfo_screenwidth() // 2) - (width // 2)
        y = (self.winfo_screenheight() // 2) - (height // 2)
        self.geometry(f'{width}x{height}+{x}+{y}')
    
    def auto_set_output_path(self, *args):
        """Automatically sets output path based on input path"""
        inp = self.input_path.get().strip()
        if inp and Path(inp).exists():
            inp_path = Path(inp)
            outp = str(inp_path.with_name(f'{inp_path.stem}_Ù†ØªØ§Ø¦Ø¬.xlsx'))
            self.output_path.set(outp)
    
    def create_ui(self):
        # Main container with padding
        main_container = ttk.Frame(self, padding="20")
        main_container.pack(fill='both', expand=True)
        
        # Title
        title_label = tk.Label(main_container, text="ğŸ§ª Ø­Ø§Ø³Ø¨Ø© Ù…Ø¹Ø¯Ù„ Ø§Ù„ØªØ¢ÙƒÙ„ Ø§Ù„Ù…ØªØ·ÙˆØ±Ø©", 
                              font=('Arial', 18, 'bold'), fg='#2c3e50')
        title_label.pack(pady=(0, 20))
        
        # Create notebook
        self.notebook = ttk.Notebook(main_container)
        self.notebook.pack(fill='both', expand=True)
        
        # Create tabs
        self.create_main_tab()
        self.create_instructions_tab()
        self.create_about_tab()
    
    def create_main_tab(self):
        main_tab = ttk.Frame(self.notebook)
        self.notebook.add(main_tab, text='ğŸ¯ Ø§Ù„Ø­Ø§Ø³Ø¨Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©')
        
        # Create scrollable frame
        canvas = tk.Canvas(main_tab)
        scrollbar = ttk.Scrollbar(main_tab, orient="vertical", command=canvas.yview)
        scrollable_frame = ttk.Frame(canvas)
        
        scrollable_frame.bind(
            "<Configure>",
            lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
        )
        
        canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
        canvas.configure(yscrollcommand=scrollbar.set)
        
        # Files Frame with enhanced styling
        file_frame = ttk.LabelFrame(scrollable_frame, text='ğŸ“ Ø¥Ø¹Ø¯Ø§Ø¯ Ù…Ù„ÙØ§Øª Ø§Ù„Ø¥Ø¯Ø®Ø§Ù„ ÙˆØ§Ù„Ø¥Ø®Ø±Ø§Ø¬', padding="15")
        file_frame.pack(fill='x', pady=(0, 15))
        
        # Input file row
        input_row = ttk.Frame(file_frame)
        input_row.pack(fill='x', pady=5)
        
        ttk.Label(input_row, text='ğŸ“‚ Ù…Ù„Ù Ø§Ù„Ø¥Ø¯Ø®Ø§Ù„ (Excel):', font=('Arial', 10, 'bold')).pack(side='left', padx=(0, 10))
        self.input_entry = ttk.Entry(input_row, textvariable=self.input_path, width=60, font=('Arial', 9))
        self.input_entry.pack(side='left', fill='x', expand=True, padx=(0, 10))
        ttk.Button(input_row, text='Ø§Ø³ØªØ¹Ø±Ø§Ø¶...', command=self.select_input).pack(side='right')
        
        # Output file row
        output_row = ttk.Frame(file_frame)
        output_row.pack(fill='x', pady=5)
        
        ttk.Label(output_row, text='ğŸ’¾ Ù…Ù„Ù Ø§Ù„Ø¥Ø®Ø±Ø§Ø¬ (Excel):', font=('Arial', 10, 'bold')).pack(side='left', padx=(0, 10))
        self.output_entry = ttk.Entry(output_row, textvariable=self.output_path, width=60, font=('Arial', 9))
        self.output_entry.pack(side='left', fill='x', expand=True, padx=(0, 10))
        ttk.Button(output_row, text='Ø§Ø³ØªØ¹Ø±Ø§Ø¶...', command=self.select_output).pack(side='right')
        
        # Settings Frame
        settings_frame = ttk.LabelFrame(scrollable_frame, text='âš™ï¸ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø©', padding="15")
        settings_frame.pack(fill='x', pady=(0, 15))
        
        # RTV Factor setting
        rtv_row = ttk.Frame(settings_frame)
        rtv_row.pack(fill='x', pady=5)
        
        ttk.Label(rtv_row, text='ğŸ”¢ Ø¹Ø§Ù…Ù„ RTV:', font=('Arial', 10, 'bold')).pack(side='left', padx=(0, 10))
        rtv_spinbox = ttk.Spinbox(rtv_row, from_=1.0, to=5.0, increment=0.001, 
                                 textvariable=self.rtv_factor, width=15, format="%.3f")
        rtv_spinbox.pack(side='left', padx=(0, 20))
        ttk.Label(rtv_row, text='(Ø§Ù„Ù‚ÙŠÙ…Ø© Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠØ©: 2.331)', font=('Arial', 9), foreground='gray').pack(side='left')
        
        # AI settings
        ai_row = ttk.Frame(settings_frame)
        ai_row.pack(fill='x', pady=10)
        
        if HAS_SK:
            ai_check = ttk.Checkbutton(ai_row, text='ğŸ¤– ØªÙØ¹ÙŠÙ„ Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ Ù„Ù„ÙƒØ´Ù Ø¹Ù† Ø§Ù„Ù‚ÙŠÙ… Ø§Ù„Ø´Ø§Ø°Ø©', 
                                      variable=self.enable_ai)
            ai_check.pack(side='left')
            ttk.Label(ai_row, text='(ÙŠØªØ·Ù„Ø¨ scikit-learn)', font=('Arial', 8), foreground='green').pack(side='left', padx=(10, 0))
        else:
            ttk.Label(ai_row, text='âš ï¸ Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ ØºÙŠØ± Ù…ØªØ§Ø­. ÙŠØ±Ø¬Ù‰ ØªØ«Ø¨ÙŠØª scikit-learn Ù„ØªÙØ¹ÙŠÙ„ Ù‡Ø°Ù‡ Ø§Ù„Ù…ÙŠØ²Ø©.', 
                     foreground='orange', font=('Arial', 10)).pack(side='left')
            self.enable_ai.set(False)
        
        # Action Buttons Frame
        action_frame = ttk.Frame(scrollable_frame)
        action_frame.pack(fill='x', pady=(0, 15))
        
        # Left side buttons
        left_buttons = ttk.Frame(action_frame)
        left_buttons.pack(side='left')
        
        preview_btn = ttk.Button(left_buttons, text='ğŸ‘ï¸ Ù…Ø¹Ø§ÙŠÙ†Ø© Ø§Ù„Ù…Ù„Ù', command=self.preview_input)
        preview_btn.pack(side='left', padx=(0, 10), ipady=8)
        
        process_btn = ttk.Button(left_buttons, text='ğŸš€ ØªØ´ØºÙŠÙ„ ÙˆØ­ÙØ¸ Ø§Ù„Ù†ØªØ§Ø¦Ø¬', command=self.run_processing)
        process_btn.pack(side='left', padx=(0, 10), ipady=8)
        
        open_output_btn = ttk.Button(left_buttons, text='ğŸ“Š ÙØªØ­ Ù…Ù„Ù Ø§Ù„Ù†ØªØ§Ø¦Ø¬', command=self.open_output_file)
        open_output_btn.pack(side='left', padx=(0, 10), ipady=8)
        
        # Right side buttons
        right_buttons = ttk.Frame(action_frame)
        right_buttons.pack(side='right')
        
        ttk.Button(right_buttons, text='âŒ Ø¥ØºÙ„Ø§Ù‚', command=self.quit).pack(side='right', ipady=8)
        
        # Progress Bar
        progress_frame = ttk.Frame(scrollable_frame)
        progress_frame.pack(fill='x', pady=(0, 15))
        
        ttk.Label(progress_frame, text='ğŸ“Š Ø´Ø±ÙŠØ· Ø§Ù„ØªÙ‚Ø¯Ù…:', font=('Arial', 10, 'bold')).pack(anchor='w')
        self.progress_bar = ttk.Progressbar(progress_frame, mode='determinate', length=600)
        self.progress_bar.pack(fill='x', pady=(5, 0))
        
        self.progress_label = ttk.Label(progress_frame, text='ÙÙŠ Ø§Ù†ØªØ¸Ø§Ø± Ø§Ù„Ø¨Ø¯Ø¡...', font=('Arial', 9))
        self.progress_label.pack(anchor='w', pady=(5, 0))
        
        # Log Panel
        log_frame = ttk.LabelFrame(scrollable_frame, text='ğŸ“‹ Ø³Ø¬Ù„ Ø§Ù„Ø¹Ù…Ù„ÙŠØ§Øª ÙˆØ§Ù„ØªÙ‚Ø§Ø±ÙŠØ± Ø§Ù„Ù…ÙØµÙ„Ø©', padding="10")
        log_frame.pack(fill='both', expand=True)
        
        # Create text widget with scrollbar
        log_container = ttk.Frame(log_frame)
        log_container.pack(fill='both', expand=True)
        
        self.txt = tk.Text(log_container, wrap='word', height=15, state='disabled', 
                          font=('Consolas', 9), bg='#f8f9fa', fg='#2c3e50')
        log_scrollbar = ttk.Scrollbar(log_container, orient='vertical', command=self.txt.yview)
        self.txt.configure(yscrollcommand=log_scrollbar.set)
        
        self.txt.pack(side='left', fill='both', expand=True)
        log_scrollbar.pack(side='right', fill='y')
        
        # Configure text tags for different message types
        self.txt.tag_configure('info', foreground='#2c3e50')
        self.txt.tag_configure('success', foreground='#27ae60', font=('Consolas', 9, 'bold'))
        self.txt.tag_configure('warning', foreground='#f39c12', font=('Consolas', 9, 'bold'))
        self.txt.tag_configure('error', foreground='#e74c3c', font=('Consolas', 9, 'bold'))
        self.txt.tag_configure('processing', foreground='#3498db', font=('Consolas', 9, 'bold'))
        
        canvas.pack(side="left", fill="both", expand=True)
        scrollbar.pack(side="right", fill="y")
        
        # Initial welcome message
        self.log_message('ğŸ‰ Ù…Ø±Ø­Ø¨Ø§Ù‹ Ø¨Ùƒ ÙÙŠ Ø­Ø§Ø³Ø¨Ø© Ù…Ø¹Ø¯Ù„ Ø§Ù„ØªØ¢ÙƒÙ„ Ø§Ù„Ù…Ø­Ø³Ù†Ø©!', 'success')
        self.log_message('ğŸ“Œ Ø§Ø¨Ø¯Ø£ Ø¨Ø§Ø®ØªÙŠØ§Ø± Ù…Ù„Ù Ø§Ù„Ø¥Ø¯Ø®Ø§Ù„ØŒ ÙˆØ³ÙŠØªÙ… ØªØ­Ø¯ÙŠØ¯ Ù…Ù„Ù Ø§Ù„Ø¥Ø®Ø±Ø§Ø¬ ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹.', 'info')
    
    def create_instructions_tab(self):
        instructions_tab = ttk.Frame(self.notebook)
        self.notebook.add(instructions_tab, text='ğŸ“– Ø¯Ù„ÙŠÙ„ Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…')
        
        # Create scrollable frame for instructions
        canvas = tk.Canvas(instructions_tab)
        scrollbar = ttk.Scrollbar(instructions_tab, orient="vertical", command=canvas.yview)
        scrollable_frame = ttk.Frame(canvas)
        
        scrollable_frame.bind("<Configure>", lambda e: canvas.configure(scrollregion=canvas.bbox("all")))
        canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
        canvas.configure(yscrollcommand=scrollbar.set)
        
        instructions_text = tk.Text(scrollable_frame, wrap='word', font=('Arial', 11), 
                                  state='normal', bg='#f8f9fa', relief='flat', 
                                  padx=20, pady=20)
        instructions_text.pack(fill='both', expand=True)
        
        # Configure text styles
        instructions_text.tag_configure('title', font=('Arial', 16, 'bold'), foreground='#2c3e50')
        instructions_text.tag_configure('section', font=('Arial', 14, 'bold'), foreground='#34495e')
        instructions_text.tag_configure('subsection', font=('Arial', 12, 'bold'), foreground='#7f8c8d')
        instructions_text.tag_configure('highlight', background='#fff3cd', foreground='#856404')
        instructions_text.tag_configure('code', font=('Consolas', 10), background='#f1f2f6', foreground='#2c3e50')
        
        # Insert comprehensive instructions
        instructions_content = """ğŸ§ª Ø¯Ù„ÙŠÙ„ Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø­Ø§Ø³Ø¨Ø© Ù…Ø¹Ø¯Ù„ Ø§Ù„ØªØ¢ÙƒÙ„ Ø§Ù„Ù…ØªØ·ÙˆØ±Ø©

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ“‹ 1. Ù†Ø¸Ø±Ø© Ø¹Ø§Ù…Ø© Ø¹Ù„Ù‰ Ø§Ù„Ø¨Ø±Ù†Ø§Ù…Ø¬

Ù‡Ø°Ø§ Ø§Ù„Ø¨Ø±Ù†Ø§Ù…Ø¬ Ù…ØµÙ…Ù… Ø®ØµÙŠØµØ§Ù‹ Ù„Ù…Ø¹Ø§Ù„Ø¬Ø© Ø¨ÙŠØ§Ù†Ø§Øª ÙØ­Øµ Ø§Ù„ØªØ¢ÙƒÙ„ ÙÙŠ Ø§Ù„Ø£Ù†Ø§Ø¨ÙŠØ¨ ÙˆØ§Ù„Ù…Ø¹Ø¯Ø§Øª Ø§Ù„ØµÙ†Ø§Ø¹ÙŠØ©. ÙŠÙ‚ÙˆÙ… Ø§Ù„Ø¨Ø±Ù†Ø§Ù…Ø¬ Ø¨Ù‚Ø±Ø§Ø¡Ø© Ù…Ù„ÙØ§Øª Excel Ø§Ù„Ù…Ø­ØªÙˆÙŠØ© Ø¹Ù„Ù‰ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù‚ÙŠØ§Ø³Ø§ØªØŒ ÙˆØ­Ø³Ø§Ø¨ Ù…Ø¹Ø¯Ù„Ø§Øª Ø§Ù„ØªØ¢ÙƒÙ„ØŒ ÙˆØ¥Ù†ØªØ§Ø¬ ØªÙ‚Ø§Ø±ÙŠØ± Ù…ÙØµÙ„Ø© ÙˆÙ…Ù†Ø³Ù‚Ø©.

ğŸ¯ Ø§Ù„Ù…Ù…ÙŠØ²Ø§Øª Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©:
â€¢ Ø­Ø³Ø§Ø¨ Ù…Ø¹Ø¯Ù„ Ø§Ù„ØªØ¢ÙƒÙ„ ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹ Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù…Ø¹Ø§Ø¯Ù„Ø§Øª Ù…Ø¹ÙŠØ§Ø±ÙŠØ©
â€¢ ÙƒØ´Ù Ø§Ù„Ù‚ÙŠÙ… Ø§Ù„Ø´Ø§Ø°Ø© Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ
â€¢ Ø¥Ù†ØªØ§Ø¬ ØªÙ‚Ø§Ø±ÙŠØ± Excel Ù…Ù†Ø³Ù‚Ø© ÙˆÙ…ÙØµÙ„Ø©
â€¢ ÙˆØ§Ø¬Ù‡Ø© Ù…Ø³ØªØ®Ø¯Ù… Ø¹Ø±Ø¨ÙŠØ© Ø³Ù‡Ù„Ø© Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…
â€¢ Ø´Ø±ÙŠØ· ØªÙ‚Ø¯Ù… Ù„Ù…ØªØ§Ø¨Ø¹Ø© Ø§Ù„Ø¹Ù…Ù„ÙŠØ§Øª
â€¢ Ø³Ø¬Ù„ Ù…ÙØµÙ„ Ù„Ù„Ø¹Ù…Ù„ÙŠØ§Øª ÙˆØ§Ù„Ù†ØªØ§Ø¦Ø¬

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ“Š 2. ØªÙ†Ø³ÙŠÙ‚ Ù…Ù„Ù Ø§Ù„Ø¥Ø¯Ø®Ø§Ù„ Ø§Ù„Ù…Ø·Ù„ÙˆØ¨

ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† Ù…Ù„Ù Ø§Ù„Ø¥Ø¯Ø®Ø§Ù„ Ø¨ØªÙ†Ø³ÙŠÙ‚ Excel (.xlsx Ø£Ùˆ .xls) ÙˆÙ…Ù†Ø¸Ù…Ø§Ù‹ ÙƒØ§Ù„ØªØ§Ù„ÙŠ:

ğŸ”¸ Ù‡ÙŠÙƒÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª:
ÙƒÙ„ Ø¬Ø²Ø¡ Ø£Ùˆ Ø£Ù†Ø¨ÙˆØ¨ ÙŠØ¨Ø¯Ø£ Ø¨Ø¹Ù†ÙˆØ§Ù† ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰:
â€¢ Ø§Ø³Ù… Ø§Ù„Ø¬Ø²Ø¡ (Ù…Ø«Ù„: "Ø£Ù†Ø¨ÙˆØ¨ Ø§Ù„Ù…ÙŠØ§Ù‡ Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ")
â€¢ Ø§Ù„Ù‚Ø·Ø± Ø¨Ø§Ù„Ø¨ÙˆØµØ© (Ù…Ø«Ù„: "12 inch" Ø£Ùˆ '8"')

ğŸ”¸ Ø±Ø¤ÙˆØ³ Ø§Ù„Ø£Ø¹Ù…Ø¯Ø© Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Ø§Ù„Ø¹Ù…ÙˆØ¯          â”‚ Ø§Ù„ÙˆØµÙ                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Points          â”‚ Ø±Ù‚Ù… Ø£Ùˆ Ø§Ø³Ù… Ø§Ù„Ù†Ù‚Ø·Ø©            â”‚
â”‚ Coth_new (Î¼m)   â”‚ Ø³Ù…Ø§ÙƒØ© Ø§Ù„Ø·Ù„Ø§Ø¡ Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©        â”‚
â”‚ Thme_new(mm)    â”‚ Ø§Ù„Ø³Ù…Ø§ÙƒØ© Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø© Ù„Ù„Ù…Ø¹Ø¯Ù†      â”‚
â”‚ RTV (mm)        â”‚ Ù‚ÙŠÙ…Ø© RTV Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø©           â”‚
â”‚ Notes           â”‚ Ù…Ù„Ø§Ø­Ø¸Ø§Øª Ø¥Ø¶Ø§ÙÙŠØ©              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ğŸ”¸ Ù…Ø«Ø§Ù„ Ø¹Ù„Ù‰ Ø§Ù„ØªÙ†Ø³ÙŠÙ‚:
Ø£Ù†Ø¨ÙˆØ¨ Ø§Ù„Ù…ÙŠØ§Ù‡ Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ 12"
Points | Coth_new (Î¼m) | Thme_new(mm) | RTV (mm)
P1     | 125          | 8.5          | 8.2
P2     | 130          | 8.3          | 8.1
...

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ§® 3. Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª ÙˆØ§Ù„Ù…Ø¹Ø§Ø¯Ù„Ø§Øª

ÙŠÙ‚ÙˆÙ… Ø§Ù„Ø¨Ø±Ù†Ø§Ù…Ø¬ Ø¨ØªÙ†ÙÙŠØ° Ø§Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ø§Ù„ØªØ§Ù„ÙŠØ©:

ğŸ”¹ Ø­Ø³Ø§Ø¨ RTV Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©:
RTV_new = Thme_new - (RTV_Factor Ã— Coth_new Ã— 0.001)

Ø­ÙŠØ«:
â€¢ RTV_Factor: Ø§Ù„Ø¹Ø§Ù…Ù„ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… (Ø§ÙØªØ±Ø§Ø¶ÙŠ 2.331)
â€¢ Coth_new: Ø³Ù…Ø§ÙƒØ© Ø§Ù„Ø·Ù„Ø§Ø¡ Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø© Ø¨Ø§Ù„Ù…ÙŠÙƒØ±ÙˆÙ†
â€¢ Thme_new: Ø§Ù„Ø³Ù…Ø§ÙƒØ© Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø© Ù„Ù„Ù…Ø¹Ø¯Ù† Ø¨Ø§Ù„Ù…Ù„ÙŠÙ…ØªØ±

ğŸ”¹ Ø­Ø³Ø§Ø¨ Ù…Ø¹Ø¯Ù„ Ø§Ù„ØªØ¢ÙƒÙ„ (CR):
CR = RTV_old - RTV_new

Ø­ÙŠØ«:
â€¢ RTV_old: Ù‚ÙŠÙ…Ø© RTV Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø© Ù…Ù† Ù…Ù„Ù Ø§Ù„Ø¥Ø¯Ø®Ø§Ù„
â€¢ RTV_new: Ù‚ÙŠÙ…Ø© RTV Ø§Ù„Ù…Ø­Ø³ÙˆØ¨Ø© Ø­Ø¯ÙŠØ«Ø§Ù‹

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ¤– 4. Ù†Ø¸Ø§Ù… Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ

Ø¹Ù†Ø¯ ØªÙØ¹ÙŠÙ„ Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠØŒ ÙŠÙ‚ÙˆÙ… Ø§Ù„Ø¨Ø±Ù†Ø§Ù…Ø¬ Ø¨Ù€:

ğŸ”¸ ÙƒØ´Ù Ø§Ù„Ù‚ÙŠÙ… Ø§Ù„Ø´Ø§Ø°Ø©:
â€¢ Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ© Isolation Forest
â€¢ ØªØ­Ù„ÙŠÙ„ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù‚ÙŠÙ… Ø§Ù„Ø±Ù‚Ù…ÙŠØ© ÙÙŠ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
â€¢ ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ù†Ù‚Ø§Ø· Ø§Ù„ØªÙŠ ØªÙ†Ø­Ø±Ù Ø¹Ù† Ø§Ù„Ù†Ù…Ø· Ø§Ù„Ø¹Ø§Ù…

ğŸ”¸ Ø§Ù„ØªÙ‚Ø±ÙŠØ±:
â€¢ Ø¹Ø±Ø¶ Ø§Ù„Ù‚ÙŠÙ… Ø§Ù„Ø´Ø§Ø°Ø© ÙÙŠ Ø¹Ù…ÙˆØ¯ Ù…Ù†ÙØµÙ„
â€¢ Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ù…ÙØµÙ„Ø© ÙÙŠ Ø³Ø¬Ù„ Ø§Ù„Ø¹Ù…Ù„ÙŠØ§Øª
â€¢ ØªÙˆØµÙŠØ§Øª Ù„Ù„Ù…Ø±Ø§Ø¬Ø¹Ø© Ø§Ù„ÙŠØ¯ÙˆÙŠØ©

âš ï¸ Ù…Ù„Ø§Ø­Ø¸Ø©: ÙŠØªØ·Ù„Ø¨ ØªØ«Ø¨ÙŠØª Ù…ÙƒØªØ¨Ø© scikit-learn

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ“„ 5. ØªÙ†Ø³ÙŠÙ‚ Ù…Ù„Ù Ø§Ù„Ø¥Ø®Ø±Ø§Ø¬

ÙŠØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ù…Ù„Ù Excel Ø¬Ø¯ÙŠØ¯ Ø¨Ø§Ù„ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„ØªØ§Ù„ÙŠ:

ğŸ”¸ Ù„ÙƒÙ„ Ø¬Ø²Ø¡:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Ø§Ø³Ù… Ø§Ù„Ø¬Ø²Ø¡: [Ø§Ø³Ù… Ø§Ù„Ø¬Ø²Ø¡] â”‚ Ù‚Ø·Ø±Ù‡ Ø¨Ø§Ù„Ø§Ù†Ø´: [Ø§Ù„Ù‚Ø·Ø±] â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Points â”‚ COth â”‚ THme â”‚ RTV â”‚ OL â”‚ CR â”‚ Ù…Ù„Ø§Ø­Ø¸Ø§Øª AI â”‚
â”‚        â”‚ (mm) â”‚ (mm) â”‚(mm) â”‚(mm)â”‚(mm)â”‚             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ P1     â”‚ 0.125â”‚ 8.5  â”‚ 8.21â”‚8.2 â”‚-0.01â”‚            â”‚
â”‚ P2     â”‚ 0.130â”‚ 8.3  â”‚ 8.00â”‚8.1 â”‚0.10 â”‚ Ù‚ÙŠÙ…Ø© Ø´Ø§Ø°Ø©  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
Ø§Ù„Ù…Ù„Ø§Ø­Ø¸Ø§Øª: [Ù…Ù„Ø§Ø­Ø¸Ø§Øª Ø§Ù„Ø¬Ø²Ø¡ Ø¥Ù† ÙˆØ¬Ø¯Øª]

ğŸ”¸ Ø§Ù„ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„Ù…ØªÙ‚Ø¯Ù…:
â€¢ Ø­Ø¯ÙˆØ¯ ÙˆØ§Ø¶Ø­Ø© Ù„Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø®Ù„Ø§ÙŠØ§
â€¢ Ø£Ù„ÙˆØ§Ù† Ù…ØªØ¯Ø±Ø¬Ø© Ù„Ù„Ø¹Ù†Ø§ÙˆÙŠÙ†
â€¢ ØªÙ†Ø³ÙŠÙ‚ Ø®Ø§Øµ Ù„Ù„Ù‚ÙŠÙ… Ø§Ù„Ø´Ø§Ø°Ø© (Ø£Ø­Ù…Ø± ÙˆØºØ§Ù…Ù‚)
â€¢ Ø¯Ù…Ø¬ Ø§Ù„Ø®Ù„Ø§ÙŠØ§ Ù„Ù„Ù…Ù„Ø§Ø­Ø¸Ø§Øª
â€¢ Ø¹Ø±Ø¶ Ø£Ø¹Ù…Ø¯Ø© Ù…Ø­Ø³Ù† Ù„Ù„Ù‚Ø±Ø§Ø¡Ø©

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸš€ 6. Ø®Ø·ÙˆØ§Øª Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…

1ï¸âƒ£ Ø§Ø®ØªÙŠØ§Ø± Ù…Ù„Ù Ø§Ù„Ø¥Ø¯Ø®Ø§Ù„:
   â€¢ Ø§Ù†Ù‚Ø± Ø¹Ù„Ù‰ "Ø§Ø³ØªØ¹Ø±Ø§Ø¶" Ø¨Ø¬Ø§Ù†Ø¨ Ù…Ù„Ù Ø§Ù„Ø¥Ø¯Ø®Ø§Ù„
   â€¢ Ø§Ø®ØªØ± Ù…Ù„Ù Excel ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª

2ï¸âƒ£ ØªØ­Ø¯ÙŠØ¯ Ù…Ù„Ù Ø§Ù„Ø¥Ø®Ø±Ø§Ø¬ (Ø§Ø®ØªÙŠØ§Ø±ÙŠ):
   â€¢ Ø³ÙŠØªÙ… ØªØ­Ø¯ÙŠØ¯Ù‡ ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹ Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ù…Ù„Ù Ø§Ù„Ø¥Ø¯Ø®Ø§Ù„
   â€¢ ÙŠÙ…ÙƒÙ†Ùƒ ØªØºÙŠÙŠØ±Ù‡ Ø­Ø³Ø¨ Ø§Ù„Ø­Ø§Ø¬Ø©

3ï¸âƒ£ Ø¶Ø¨Ø· Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª:
   â€¢ ØªØ¹Ø¯ÙŠÙ„ Ø¹Ø§Ù…Ù„ RTV Ø¥Ø°Ø§ Ù„Ø²Ù… Ø§Ù„Ø£Ù…Ø±
   â€¢ ØªÙØ¹ÙŠÙ„/Ø¥Ù„ØºØ§Ø¡ Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ

4ï¸âƒ£ Ø§Ù„Ù…Ø¹Ø§ÙŠÙ†Ø© (Ø§Ø®ØªÙŠØ§Ø±ÙŠ):
   â€¢ Ø§Ù†Ù‚Ø± "Ù…Ø¹Ø§ÙŠÙ†Ø© Ø§Ù„Ù…Ù„Ù" Ù„Ù„ØªØ£ÙƒØ¯ Ù…Ù† ØµØ­Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª

5ï¸âƒ£ ØªØ´ØºÙŠÙ„ Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø©:
   â€¢ Ø§Ù†Ù‚Ø± "ØªØ´ØºÙŠÙ„ ÙˆØ­ÙØ¸ Ø§Ù„Ù†ØªØ§Ø¦Ø¬"
   â€¢ ØªØ§Ø¨Ø¹ Ø§Ù„ØªÙ‚Ø¯Ù… ÙÙŠ Ø´Ø±ÙŠØ· Ø§Ù„ØªÙ‚Ø¯Ù…

6ï¸âƒ£ Ù…Ø±Ø§Ø¬Ø¹Ø© Ø§Ù„Ù†ØªØ§Ø¦Ø¬:
   â€¢ Ø§Ù†Ù‚Ø± "ÙØªØ­ Ù…Ù„Ù Ø§Ù„Ù†ØªØ§Ø¦Ø¬" Ù„Ù…Ø´Ø§Ù‡Ø¯Ø© Ø§Ù„ØªÙ‚Ø±ÙŠØ±
   â€¢ Ø±Ø§Ø¬Ø¹ Ø³Ø¬Ù„ Ø§Ù„Ø¹Ù…Ù„ÙŠØ§Øª Ù„Ù„ØªÙØ§ØµÙŠÙ„

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

âš ï¸ 7. Ù†ØµØ§Ø¦Ø­ Ù…Ù‡Ù…Ø© ÙˆÙ…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø£Ø®Ø·Ø§Ø¡

ğŸ”¸ Ù…ØªØ·Ù„Ø¨Ø§Øª Ù…Ù„Ù Ø§Ù„Ø¥Ø¯Ø®Ø§Ù„:
â€¢ ØªØ£ÙƒØ¯ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ø¹Ù†Ø§ÙˆÙŠÙ† Ø§Ù„Ø£Ø¬Ø²Ø§Ø¡ Ø¨ÙˆØ¶ÙˆØ­
â€¢ ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© Ø£Ø³Ù…Ø§Ø¡ Ø§Ù„Ø£Ø¹Ù…Ø¯Ø©
â€¢ ØªØ£ÙƒØ¯ Ù…Ù† Ø£Ù† Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø±Ù‚Ù…ÙŠØ© ØµØ­ÙŠØ­Ø©

ğŸ”¸ Ø§Ù„Ø£Ø®Ø·Ø§Ø¡ Ø§Ù„Ø´Ø§Ø¦Ø¹Ø©:
â€¢ "Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø¨ÙŠØ§Ù†Ø§Øª ØµØ§Ù„Ø­Ø©": ØªØ­Ù‚Ù‚ Ù…Ù† ØªÙ†Ø³ÙŠÙ‚ Ø§Ù„Ù…Ù„Ù
â€¢ "Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ù‚Ø±Ø§Ø¡Ø©": ØªØ£ÙƒØ¯ Ø£Ù† Ø§Ù„Ù…Ù„Ù Ù„ÙŠØ³ Ù…ÙØªÙˆØ­Ø§Ù‹ ÙÙŠ Ø¨Ø±Ù†Ø§Ù…Ø¬ Ø¢Ø®Ø±
â€¢ "ÙØ´Ù„ ÙÙŠ Ø§Ù„Ø­ÙØ¸": ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª ÙˆÙ…Ø³Ø§Ø­Ø© Ø§Ù„Ù‚Ø±Øµ

ğŸ”¸ Ù†ØµØ§Ø¦Ø­ Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø£ÙØ¶Ù„ Ø§Ù„Ù†ØªØ§Ø¦Ø¬:
â€¢ Ø§Ø³ØªØ®Ø¯Ù… Ø£Ø³Ù…Ø§Ø¡ ÙˆØ§Ø¶Ø­Ø© Ù„Ù„Ø£Ø¬Ø²Ø§Ø¡
â€¢ ØªØ£ÙƒØ¯ Ù…Ù† Ø¯Ù‚Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø¯Ø®Ù„Ø©
â€¢ Ø±Ø§Ø¬Ø¹ Ø§Ù„Ù‚ÙŠÙ… Ø§Ù„Ø´Ø§Ø°Ø© Ø§Ù„Ù…ÙƒØªØ´ÙØ© ÙŠØ¯ÙˆÙŠØ§Ù‹
â€¢ Ø§Ø­ØªÙØ¸ Ø¨Ù†Ø³Ø® Ø§Ø­ØªÙŠØ§Ø·ÙŠØ© Ù…Ù† Ø§Ù„Ù…Ù„ÙØ§Øª

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ“ 8. Ø§Ù„Ø¯Ø¹Ù… ÙˆØ§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø©

Ø¥Ø°Ø§ ÙˆØ§Ø¬Ù‡Øª Ø£ÙŠ Ù…Ø´Ø§ÙƒÙ„ Ø£Ùˆ ÙƒØ§Ù† Ù„Ø¯ÙŠÙƒ Ø§Ø³ØªÙØ³Ø§Ø±Ø§Øª:
â€¢ Ø±Ø§Ø¬Ø¹ Ø³Ø¬Ù„ Ø§Ù„Ø¹Ù…Ù„ÙŠØ§Øª Ù„Ù„ØªÙØ§ØµÙŠÙ„ Ø§Ù„Ù…ÙØµÙ„Ø©
â€¢ ØªØ£ÙƒØ¯ Ù…Ù† ØªØ«Ø¨ÙŠØª Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…ÙƒØªØ¨Ø§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©
â€¢ ØªØ­Ù‚Ù‚ Ù…Ù† ØªÙ†Ø³ÙŠÙ‚ Ù…Ù„Ù Ø§Ù„Ø¥Ø¯Ø®Ø§Ù„

ğŸ¯ Ø§Ù„Ø¨Ø±Ù†Ø§Ù…Ø¬ Ù…ØµÙ…Ù… Ù„ÙŠÙƒÙˆÙ† Ø³Ù‡Ù„ Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù… ÙˆØ¯Ù‚ÙŠÙ‚ ÙÙŠ Ø§Ù„Ù†ØªØ§Ø¦Ø¬. 
   Ø§Ø³ØªÙ…ØªØ¹ Ø¨Ø§Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…! ğŸš€"""
        
        instructions_text.insert('1.0', instructions_content)
        instructions_text.config(state='disabled')
        
        canvas.pack(side="left", fill="both", expand=True)
        scrollbar.pack(side="right", fill="y")
    
    def create_about_tab(self):
        about_tab = ttk.Frame(self.notebook)
        self.notebook.add(about_tab, text='â„¹ï¸ Ø­ÙˆÙ„ Ø§Ù„Ø¨Ø±Ù†Ø§Ù…Ø¬')
        
        about_frame = ttk.Frame(about_tab, padding="30")
        about_frame.pack(fill='both', expand=True)
        
        # Title
        title_label = tk.Label(about_frame, text="ğŸ§ª Ø­Ø§Ø³Ø¨Ø© Ù…Ø¹Ø¯Ù„ Ø§Ù„ØªØ¢ÙƒÙ„ Ø§Ù„Ù…ØªØ·ÙˆØ±Ø©", 
                              font=('Arial', 20, 'bold'), fg='#2c3e50')
        title_label.pack(pady=(0, 20))
        
        # Version info
        version_label = tk.Label(about_frame, text="Ø§Ù„Ø¥ØµØ¯Ø§Ø± 2.0 Ø§Ù„Ù…Ø­Ø³Ù† - 2024", 
                                font=('Arial', 12), fg='#7f8c8d')
        version_label.pack(pady=(0, 30))
        
        # Features
        features_text = """
ğŸ¯ Ø§Ù„Ù…Ù…ÙŠØ²Ø§Øª Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©:

âœ… Ø­Ø³Ø§Ø¨ Ù…Ø¹Ø¯Ù„ Ø§Ù„ØªØ¢ÙƒÙ„ ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹ Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ù…Ø¹Ø§Ø¯Ù„Ø§Øª Ø§Ù„Ù…Ø¹ÙŠØ§Ø±ÙŠØ©
âœ… ÙƒØ´Ù Ø§Ù„Ù‚ÙŠÙ… Ø§Ù„Ø´Ø§Ø°Ø© Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ§Øª Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ
âœ… Ø¥Ù†ØªØ§Ø¬ ØªÙ‚Ø§Ø±ÙŠØ± Excel Ù…ÙØµÙ„Ø© ÙˆÙ…Ù†Ø³Ù‚Ø© Ø¨Ø´ÙƒÙ„ Ø§Ø­ØªØ±Ø§ÙÙŠ
âœ… ÙˆØ§Ø¬Ù‡Ø© Ù…Ø³ØªØ®Ø¯Ù… Ø¹Ø±Ø¨ÙŠØ© Ø³Ù‡Ù„Ø© ÙˆÙ…ØªØ·ÙˆØ±Ø©
âœ… Ø´Ø±ÙŠØ· ØªÙ‚Ø¯Ù… Ù„Ù…ØªØ§Ø¨Ø¹Ø© Ø§Ù„Ø¹Ù…Ù„ÙŠØ§Øª ÙÙŠ Ø§Ù„ÙˆÙ‚Øª Ø§Ù„ÙØ¹Ù„ÙŠ
âœ… Ø³Ø¬Ù„ Ù…ÙØµÙ„ Ù„Ù„Ø¹Ù…Ù„ÙŠØ§Øª ÙˆØ§Ù„Ù†ØªØ§Ø¦Ø¬
âœ… Ø¯Ø¹Ù… Ù…Ù„ÙØ§Øª Excel Ù…ØªØ¹Ø¯Ø¯Ø© Ø§Ù„Ø£ÙˆØ±Ø§Ù‚
âœ… Ø­ÙØ¸ ØªÙ„Ù‚Ø§Ø¦ÙŠ Ù…Ø¹ ØªØ³Ù…ÙŠØ© Ø°ÙƒÙŠØ© Ù„Ù„Ù…Ù„ÙØ§Øª

ğŸ”§ Ø§Ù„ØªÙ‚Ù†ÙŠØ§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…Ø©:

â€¢ Python 3.7+
â€¢ Tkinter Ù„Ù„ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„Ø±Ø³ÙˆÙ…ÙŠØ©
â€¢ Pandas Ù„Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
â€¢ OpenPyXL Ù„Ù„ØªØ¹Ø§Ù…Ù„ Ù…Ø¹ Ù…Ù„ÙØ§Øª Excel
â€¢ Scikit-learn Ù„Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ
â€¢ NumPy Ù„Ù„Ø­Ø³Ø§Ø¨Ø§Øª Ø§Ù„Ø±ÙŠØ§Ø¶ÙŠØ©

ğŸ“Š ÙŠØ¯Ø¹Ù… Ø§Ù„Ø¨Ø±Ù†Ø§Ù…Ø¬ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø¢Ù„Ø§Ù Ø§Ù„Ù†Ù‚Ø§Ø· ÙÙŠ Ø«ÙˆØ§Ù†Ù Ù…Ø¹Ø¯ÙˆØ¯Ø©!
        """
        
        features_label = tk.Label(about_frame, text=features_text, 
                                 font=('Arial', 11), justify='right', fg='#34495e')
        features_label.pack(pady=20)
        
        # Copyright
        copyright_label = tk.Label(about_frame, 
                                  text="Â© 2024 - Ø¨Ø±Ù†Ø§Ù…Ø¬ Ù…Ø·ÙˆØ± Ø®ØµÙŠØµØ§Ù‹ Ù„Ø­Ø³Ø§Ø¨ Ù…Ø¹Ø¯Ù„ Ø§Ù„ØªØ¢ÙƒÙ„ ÙÙŠ Ø§Ù„Ù…Ø¹Ø¯Ø§Øª Ø§Ù„ØµÙ†Ø§Ø¹ÙŠØ©", 
                                  font=('Arial', 10), fg='#95a5a6')
        copyright_label.pack(pady=(30, 0))
    
    def log_message(self, msg, tag='info'):
        """Enhanced logging with colored messages and timestamps"""
        timestamp = datetime.datetime.now().strftime('%H:%M:%S')
        log_entry = f'[{timestamp}] {msg}\n'
        
        self.txt.config(state='normal')
        start_pos = self.txt.index('end-1c')
        self.txt.insert('end', log_entry)
        
        # Apply tag for styling
        end_pos = self.txt.index('end-1c')
        self.txt.tag_add(tag, start_pos, end_pos)
        
        self.txt.see('end')
        self.txt.config(state='disabled')
        self.update_idletasks()
    
    def update_progress(self, value, status=""):
        """Update progress bar and status"""
        self.progress_bar['value'] = value
        if status:
            self.progress_label.config(text=status)
        self.update_idletasks()
    
    def select_input(self):
        filetypes = [
            ('Excel files', '*.xlsx *.xls'),
            ('Excel 2007+', '*.xlsx'),
            ('Excel 97-2003', '*.xls'),
            ('All files', '*.*')
        ]
        p = filedialog.askopenfilename(
            title='Ø§Ø®ØªÙŠØ§Ø± Ù…Ù„Ù Ø§Ù„Ø¥Ø¯Ø®Ø§Ù„',
            filetypes=filetypes
        )
        if p:
            self.input_path.set(p)
            self.log_message(f'ØªÙ… Ø§Ø®ØªÙŠØ§Ø± Ù…Ù„Ù Ø§Ù„Ø¥Ø¯Ø®Ø§Ù„: {Path(p).name}', 'success')
    
    def select_output(self):
        p = filedialog.asksaveasfilename(
            title='Ø§Ø®ØªÙŠØ§Ø± Ù…ÙˆÙ‚Ø¹ Ø­ÙØ¸ Ø§Ù„Ù†ØªØ§Ø¦Ø¬',
            defaultextension='.xlsx',
            filetypes=[
                ('Excel 2007+', '*.xlsx'),
                ('All files', '*.*')
            ]
        )
        if p:
            self.output_path.set(p)
            self.log_message(f'ØªÙ… ØªØ­Ø¯ÙŠØ¯ Ù…Ø³Ø§Ø± Ø§Ù„Ø¥Ø®Ø±Ø§Ø¬: {Path(p).name}', 'success')
    
    def preview_input(self):
        p = self.input_path.get().strip()
        if not p:
            messagebox.showwarning('ØªØ­Ø°ÙŠØ±', 'Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø§Ø®ØªÙŠØ§Ø± Ù…Ù„Ù Ø¥Ø¯Ø®Ø§Ù„ Ø£ÙˆÙ„Ø§Ù‹.')
            return
        
        if not Path(p).exists():
            messagebox.showerror('Ø®Ø·Ø£', 'Ø§Ù„Ù…Ù„Ù Ø§Ù„Ù…Ø­Ø¯Ø¯ ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯.')
            return
        
        self.log_message('Ø¬Ø§Ø±ÙŠ Ù…Ø¹Ø§ÙŠÙ†Ø© Ø§Ù„Ù…Ù„Ù...', 'processing')
        try:
            xls = pd.read_excel(p, sheet_name=None, header=None, dtype=str)
            self.log_message(f'ØªÙ… ÙØªØ­ Ø§Ù„Ù…Ù„Ù Ø¨Ù†Ø¬Ø§Ø­: {Path(p).name}', 'success')
            
            total_sheets = len(xls)
            total_rows = sum(df.shape[0] for df in xls.values())
            total_cols = max(df.shape[1] for df in xls.values()) if xls else 0
            
            self.log_message(f'ğŸ“Š Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ù…Ù„Ù:', 'info')
            self.log_message(f'   â€¢ Ø¹Ø¯Ø¯ Ø£ÙˆØ±Ø§Ù‚ Ø§Ù„Ø¹Ù…Ù„: {total_sheets}', 'info')
            self.log_message(f'   â€¢ Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„ØµÙÙˆÙ: {total_rows:,}', 'info')
            self.log_message(f'   â€¢ Ø£Ù‚ØµÙ‰ Ø¹Ø¯Ø¯ Ø£Ø¹Ù…Ø¯Ø©: {total_cols}', 'info')
            
            for sheet_name, df in xls.items():
                self.log_message(f'   â€¢ ÙˆØ±Ù‚Ø© "{sheet_name}": {df.shape[0]} ØµÙ Ã— {df.shape[1]} Ø¹Ù…ÙˆØ¯', 'info')
                
        except Exception as e:
            self.log_message(f'Ø®Ø·Ø£ ÙÙŠ Ù…Ø¹Ø§ÙŠÙ†Ø© Ø§Ù„Ù…Ù„Ù: {str(e)}', 'error')
            messagebox.showerror('Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ù…Ø¹Ø§ÙŠÙ†Ø©', f'Ø­Ø¯Ø« Ø®Ø·Ø£: {e}')
    
    def open_output_file(self):
        """Open the output file if it exists"""
        output_path = self.output_path.get().strip()
        if not output_path:
            messagebox.showwarning('ØªØ­Ø°ÙŠØ±', 'Ù„Ù… ÙŠØªÙ… ØªØ­Ø¯ÙŠØ¯ Ù…Ù„Ù Ø¥Ø®Ø±Ø§Ø¬.')
            return
        
        if not Path(output_path).exists():
            messagebox.showwarning('ØªØ­Ø°ÙŠØ±', 'Ù…Ù„Ù Ø§Ù„Ø¥Ø®Ø±Ø§Ø¬ ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯. ÙŠØ±Ø¬Ù‰ ØªØ´ØºÙŠÙ„ Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø© Ø£ÙˆÙ„Ø§Ù‹.')
            return
        
        try:
            if sys.platform == "win32":
                os.startfile(output_path)
            elif sys.platform == "darwin":
                subprocess.call(["open", output_path])
            else:
                subprocess.call(["xdg-open", output_path])
            self.log_message(f'ØªÙ… ÙØªØ­ Ù…Ù„Ù Ø§Ù„Ù†ØªØ§Ø¦Ø¬: {Path(output_path).name}', 'success')
        except Exception as e:
            self.log_message(f'Ø®Ø·Ø£ ÙÙŠ ÙØªØ­ Ø§Ù„Ù…Ù„Ù: {str(e)}', 'error')
            messagebox.showerror('Ø®Ø·Ø£', f'Ù„Ø§ ÙŠÙ…ÙƒÙ† ÙØªØ­ Ø§Ù„Ù…Ù„Ù: {e}')
    
    def run_processing(self):
        if self.processing:
            messagebox.showinfo('ØªÙ†Ø¨ÙŠÙ‡', 'Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø© Ù‚ÙŠØ¯ Ø§Ù„ØªØ´ØºÙŠÙ„ Ø­Ø§Ù„ÙŠØ§Ù‹. ÙŠØ±Ø¬Ù‰ Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø±.')
            return
        
        inp = self.input_path.get().strip()
        outp = self.output_path.get().strip()
        
        if not inp:
            messagebox.showwarning('ØªØ­Ø°ÙŠØ±', 'ÙŠØ¬Ø¨ Ø§Ø®ØªÙŠØ§Ø± Ù…Ù„Ù Ø¥Ø¯Ø®Ø§Ù„.')
            return
        
        if not Path(inp).exists():
            messagebox.showerror('Ø®Ø·Ø£', 'Ù…Ù„Ù Ø§Ù„Ø¥Ø¯Ø®Ø§Ù„ ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯.')
            return
        
        if not outp:
            messagebox.showwarning('ØªØ­Ø°ÙŠØ±', 'ÙŠØ¬Ø¨ ØªØ­Ø¯ÙŠØ¯ Ù…Ù„Ù Ø§Ù„Ø¥Ø®Ø±Ø§Ø¬.')
            return
        
        # Start processing in a separate thread
        self.processing = True
        self.progress_bar['value'] = 0
        self.progress_label.config(text='Ø¨Ø¯Ø¡ Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø©...')
        
        def process():
            try:
                self.log_message('=' * 60, 'processing')
                self.log_message('ğŸš€ Ø¨Ø¯Ø¡ Ø¹Ù…Ù„ÙŠØ© Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø´Ø§Ù…Ù„Ø©', 'processing')
                self.log_message('=' * 60, 'processing')
                
                def progress_callback(value):
                    self.after(0, lambda: self.update_progress(value, f'Ø¬Ø§Ø±ÙŠ Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø©... {value}%'))
                
                def log_callback(msg):
                    if 'âœ…' in msg or 'ØªÙ…' in msg:
                        tag = 'success'
                    elif 'âš ï¸' in msg or 'ØªØ­Ø°ÙŠØ±' in msg:
                        tag = 'warning'
                    elif 'âŒ' in msg or 'Ø®Ø·Ø£' in msg:
                        tag = 'error'
                    elif 'ğŸ”„' in msg or 'ğŸ”' in msg or 'âš™ï¸' in msg:
                        tag = 'processing'
                    else:
                        tag = 'info'
                    self.after(0, lambda m=msg, t=tag: self.log_message(m, t))
                
                result_path = process_excel_file(
                    input_path=inp,
                    output_path=outp,
                    rtv_factor=self.rtv_factor.get(),
                    enable_ai=self.enable_ai.get(),
                    log_callback=log_callback,
                    progress_callback=progress_callback
                )
                
                self.after(0, lambda: self.processing_complete(result_path))
                
            except Exception as e:
                self.after(0, lambda: self.processing_error(str(e)))
        
        thread = threading.Thread(target=process, daemon=True)
        thread.start()
    
    def processing_complete(self, result_path):
        """Handle successful completion"""
        self.processing = False
        self.update_progress(100, 'Ø§ÙƒØªÙ…Ù„Øª Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø© Ø¨Ù†Ø¬Ø§Ø­! âœ…')
        
        self.log_message('=' * 60, 'success')
        self.log_message('ğŸ‰ ØªÙ…Øª Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø© Ø¨Ù†Ø¬Ø§Ø­!', 'success')
        self.log_message(f'ğŸ“ Ù…Ù„Ù Ø§Ù„Ù†ØªØ§Ø¦Ø¬: {Path(result_path).name}', 'success')
        self.log_message('=' * 60, 'success')
        
        # Show completion dialog with options
        result = messagebox.askyesno(
            'ØªÙ…Øª Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø© Ø¨Ù†Ø¬Ø§Ø­! ğŸ‰',
            f'ØªÙ… Ø­ÙØ¸ Ø§Ù„Ù†ØªØ§Ø¦Ø¬ ÙÙŠ:\n{result_path}\n\nÙ‡Ù„ ØªØ±ÙŠØ¯ ÙØªØ­ Ø§Ù„Ù…Ù„Ù Ø§Ù„Ø¢Ù†ØŸ'
        )
        
        if result:
            self.open_output_file()
    
    def processing_error(self, error_msg):
        """Handle processing error"""
        self.processing = False
        self.update_progress(0, 'Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø© âŒ')
        
        self.log_message('=' * 60, 'error')
        self.log_message(f'âŒ ÙØ´Ù„Øª Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø©: {error_msg}', 'error')
        self.log_message('=' * 60, 'error')
        
        messagebox.showerror('Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø©', f'Ø­Ø¯Ø« Ø®Ø·Ø£:\n{error_msg}')

# ------------------ Main Application Entry Point ------------------

def main():
    """Main function to run the application"""
    try:
        app = CorrosionApp()
        app.mainloop()
    except Exception as e:
        messagebox.showerror('Ø®Ø·Ø£ ÙÙŠ ØªØ´ØºÙŠÙ„ Ø§Ù„Ø¨Ø±Ù†Ø§Ù…Ø¬', f'Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ ØªØ´ØºÙŠÙ„ Ø§Ù„Ø¨Ø±Ù†Ø§Ù…Ø¬:\n{e}')

if __name__ == '__main__':
    main()
